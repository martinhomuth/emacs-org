#+STARTUP: indent content hidestars
* Personal Information

If for some reason any application will need personal information,
here they are ;-)

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Martin Homuth")
#+END_SRC

#+RESULTS:
: Martin Homuth

Load all the things I don't like to share with the world

#+BEGIN_SRC emacs-lisp
(load (concat (getenv "HOME") "/.emacs.d/secrets"))
#+END_SRC

#+RESULTS:
: t

* Emacs Initialization

These settings are for emacs internals, nothing specific.

** Emacs Font
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'default-frame-alist
  ;;              `(font . ,(concat "DejaVu Sans Mono-" (number-to-string fontsize))))
  ;; (set-fontset-font "fontset-default" nil
  ;;                   (font-spec :size 20 :name "Symbola"))
  ;; disable CJK coding/encoding
  (setq utf-translate-cjk-mode nil)
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-file-name-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)

  ;; backwards compatibility
  (if (boundp buffer-file-coding-system)
      (setq buffer-file-coding-system 'utf-8)
    (setq default-buffer-file-coding-system 'utf-8))

  ;; Treat clipboard as UTF-8 string first
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |

** Themes

My desktop machine(s) have a light i3 theme currently while the
notebook maintains a dark theme. That's why I chose to make a
difference here. This is hidden in secrets.el to avoid information
leaking about differences.

#+BEGIN_SRC emacs-lisp
  ;;; As mytheme can be nil, guard it
  (if (not (eq mytheme nil))
      (load-theme mytheme t))
  (setq-default cursor-type 'box)
  (global-hl-line-mode)

#+END_SRC

#+RESULTS:
: t

** Server

Starting the server at emacs start should be handy someday..

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

#+RESULTS:

** Backup

The file backups emacs uses are pretty annoying, so I place them in a
separate directory instead of next to the file in use. If needed these
files are accessible there quite easily.

If this variable is nil, or it fails to match a filename, the backup
is made in the original file's directory. This is what I really don't
want.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

** Add Package Sources

   #+BEGIN_SRC emacs-lisp
     (unless (assoc-default "melpa" package-archives)
       (add-to-list 'package-archives
      	      '("melpa" . "http://melpa.org/packages/")))

     (unless (assoc-default "org" package-archives)
       (add-to-list 'package-archives
      	      '("org" . "http://orgmode.org/elpa/")))
   #+END_SRC

   #+RESULTS:

** Add elisp directory and other files

Sacha uses external (wrt not package) files, which I'll enable too,
just to make sure it is there if I ever need it.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat (getenv "HOME") "/elisp"))
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose t)
  (use-package auto-compile
    :ensure t
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))
#+END_SRC

#+RESULTS:
: t

** General Configuration

#+BEGIN_SRC emacs-lisp
  (when window-system
    (tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (line-number-mode -1)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
          visible-bell t))

  (setq fill-column 85
        initial-scratch-message "")

  ; Whitespaces... A colleague of mine showed me the horror of not
  ; considering whitespaces and thus they are shown always and everywhere!
  (setq-default show-trailing-whitespace t)

  (fset 'yes-or-no-p 'y-or-n-p)
  (prefer-coding-system 'utf-8)
  (delete-selection-mode t)
#+END_SRC

#+RESULTS:
: t

A good addition is to toggle every whitespace character on demand.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :bind ("C-c T w" . whitespace-mode)
    :init
    (setq whitespace-line-column nil
          whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [9166 10])
                                        (tab-mark 9 [9654 9] [92 9])))
    :config
    (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
    :diminish whitespace-mode)
#+END_SRC

#+RESULTS:

** Tramp

It is really important, that the prompt that is going to be accessed
by tamp is `simple`. The following excerpt from my zsh.theme shows a
possibility to solve this:

#+BEGIN_SRC sh :tangle no :eval no
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
     PROMPT="%m> "
  else
     PROMPT="%(?.%(!.#.;).%F{1}%B;%b%f) "
  fi
#+END_SRC

Tramp itself can have various configurations for default settings.

#+BEGIN_SRC emacs-lisp :eval no
  (setq tramp-default-method "ssh"
        tramp-default-user "martin")
#+END_SRC

#+RESULTS:
: martin

** Helm - Interactive Completion

#+BEGIN_SRC emacs-lisp
  (use-package helm
               :ensure helm
               :diminish helm-mode
               :config
               (progn
                 (require 'helm-config)
                 (setq helm-candidate-number-limit 100)
                 (setq helm-idle-delay 0.0
                       helm-input-idle-delay 0.01
                       helm-quick-update t
                       helm-M-x-requires-pattern nil)
                 (helm-mode))
               :bind (("C-c h" . helm-mini)
                      ("C-h a" . helm-apropos)
                      ("C-x C-f" . helm-find-files)
                      ("C-x C-b" . helm-buffers-list)
                      ("C-x b" . helm-buffers-list)
                      ("M-y" . helm-show-kill-ring)
                      ("M-x" . helm-M-x)
                      ("C-x c o" . helm-occur)
                      ("C-x c s" . helm-scoop)))
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure windmove
    :ensure ace-window
    :ensure hydra
    :init
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window ()
       "window"
       ("h" windmove-left)
       ("j" windmove-down)
       ("k" windmove-up)
       ("l" windmove-right)
       ("v" (\lambda ()
             (interactive)
             (split-window-right)
             (windmove-right))
        "vert")
       ("x" (\lambda ()
             (interactive)
             (split-window-below)
             (windmove-down))
        "horz")
       ("t" transpose-frame "'")
       ("o" delete-other-windows "one" :color blue)
       ("a" ace-window "ace")
       ("s" ace-swap-window "swap")
       ("d" ace-delete-window "del")
       ("i" ace-maximize-window "ace-one" :color blue)
       ("b" switch-to-buffer "buf")
       ("m" headlong-bookmark-jump "bmk")
       ("q" nil "cancel"))))
#+END_SRC

#+RESULTS:

** Startup File

Load my personal org file after startup.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
	initial-buffer-choice (expand-file-name (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org")))
#+END_SRC

#+RESULTS:
: /home/martin/git/CG_bitbucket/org/personal.org

** Exit Confirmation

Even though unsaved buffers saved me lots of times due to prompting
for save, it happened quite often that I closed Emacs because of
mistyping. Maybe a confirmation helps and is not really annoying -
when in window system.

#+BEGIN_SRC emacs-lisp
  (defun martin-save-buffers-kill-emacs-with-confirm ()
    "Thanks to jsled for this method"
    (interactive)
    (if (window-system)
	(if (null current-prefix-arg)
	    (if (y-or-n-p "Are you sure you want to quit?")
		(save-buffers-kill-emacs))
	  (save-buffers-kill-emacs))
      (save-buffers-kill-terminal)))
  (global-set-key "\C-x\C-c" 'martin-save-buffers-kill-emacs-with-confirm)
#+END_SRC

#+RESULTS:
: martin-save-buffers-kill-emacs-with-confirm

** Snippets

From Sacha Chuas Configuration for testing

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode ;; used to remove mode line information that is not used
    :init (yas-global-mode)
    :config
    (progn
      (yas-global-mode)
      (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
      (setq yas-key-syntaxes '("w_" "w_." "^ "))
      (setq yas-installed-snippets-dir (concat (getenv "HOME") "/elisp/yasnippet-snippets"))
      (setq yas-expand-only-for-last-commands nil)
      (yas-global-mode 1)
      (bind-key "\t" 'hippie-expand yas-minor-mode-map)))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
  (setq default-cursor-color "gray")
  (setq yasnippet-can-fire-cursor-color "purple")

  ;; It will test whether it can expand, if yes, cursor color -> green.
  (defun yasnippet-can-fire-p (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
	(setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
							(yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (and templates-and-pos (first templates-and-pos))))

  (defun my/change-cursor-color-when-can-expand (&optional field)
    (interactive)
    (when (eq last-command 'self-insert-command)
      (set-cursor-color (if (my/can-expand)
                            yasnippet-can-fire-cursor-color
                          default-cursor-color))))

  (defun my/can-expand ()
    "Return true if right after an expandable thing."
    (or (abbrev--before-point) (yasnippet-can-fire-p)))

  (add-hook 'post-command-hook 'my/change-cursor-color-when-can-expand)

  (defun my/insert-space-or-expand ()
    "For binding to the SPC SPC keychord."
    (interactive)
    (condition-case nil (or (my/hippie-expand-maybe nil) (insert "  "))))
#+END_SRC

#+RESULTS:
: my/insert-space-or-expand

** Key Bindings
#+BEGIN_SRC emacs-lisp
  ;; General
  (global-set-key "\C-cw" 'compare-windows)
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-unset-key (kbd "C-z")) ;; who needs that anyways?
  (global-set-key (kbd "M-o") 'other-window)
  (global-unset-key "\C-xf")
  (global-set-key [f1] 'eshell)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  ;; Org-Mode
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c O" 'org-open-at-point-global)
  (bind-key "<f9>" 'org-agenda-list)
  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)
#+END_SRC

#+RESULTS:
: org-agenda-clock-in

#+END_SRC

#+RESULTS:
: magit-status


* Navigation
** Better Beginning Of The Line

Thanks to Howard Abrams for this neat function!

#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
  (global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line

** Better delete line

I am used to delete my lines using C-k and with the previous changes
from Better Beginning Of The Line this can be cumbersome. Therefore
there is a need for changing this behavior to deleting the whole line
if the point is at the beginning of the line.

#+BEGIN_SRC emacs-lisp :eval no :tangle no
  (defun hungry-eat-line ()
    ""
    (interactive)
    (save-excursion
      (let ((indent-point
             (save-excursion
               (back-to-indentation)
        (if (= indent-point (point))
            (kill-whole-line)
          (kill-line nil))))))))

  (global-set-key (kbd "C-k") 'hungry-eat-line)
#+END_SRC

#+RESULTS:
: hungry-eat-line

** Helm-Swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :defer t
    :bind
    (("C-S-s" . helm-swoop)
     ("M-i" . helm-swoop)
     ("M-s s" . helm-swoop)
     ("C-x M-i" . helm-multi-swoop-all))
    :config
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+END_SRC

#+RESULTS:

** Moving Files

Moving files using /rename-file/ or /dired-do-rename/ does not modify the
buffer of that file, which is not what I usually want. Taken from [[http://zck.me/emacs-move-file][here]]
is a method to not just rename the file but also the buffer associated
with the file.

#+BEGIN_SRC emacs-lisp
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (if buffer-file-name
			   (read-file-name "Move file to: ")
			 (read-file-name "Move file to: "
					 default-directory
					 (expand-file-name (file-name-nondirectory (buffer-name))
							   default-directory)))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (buffer-file-name)))
      (write-file new-location t)
      (when (and old-location
		 (file-exists-p new-location)
		 (not (string-equal old-location new-location)))
	(delete-file old-location))))

  (bind-key "C-x C-m" 'move-file)
#+END_SRC

** Dired

Handling dired buffers is kind of cumbersome for me, especially
because opening a folder means more buffers for every folder I
enter. This is not bad per se, but not really what I would
like. Following the great emacs news by Sacha Chua, I found [[http://xenodium.com/#drill-down-emacs-dired-with-dired-subtree][this]] on
reddit:

#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (setq dired-subtree-use-backgrounds nil)
    (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))
#+END_SRC

#+RESULTS:
: t

* Input
** Auto Fill
   #+BEGIN_SRC emacs-lisp
     (setq major-mode 'org-mode)
     (add-hook 'org-mode-hook 'turn-on-auto-fill)
     (add-hook 'c-mode-hook 'turn-on-auto-fill)
     (add-hook 'TeX-mode-hook 'turn-on-auto-fill)
   #+END_SRC

   #+RESULTS:
   | turn-on-auto-fill |

** Default input method

I use the 'german-prefix' input method regularly and thus this should
be the default all the time. Maybe I'll tweak that someday if becomes
cumbersome.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method "german-prefix")
#+END_SRC

#+RESULTS:
: german-prefix

* Version Control
** Git

Magit seems to be the one and only package when dealing with git
repositories. We will see, if there is something else needed ever.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (setq magit-auto-revert-mode nil)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

#+RESULTS:

** Symbolic Links

The default behavior of emacs is to ask whether to follow symbolic
links or not. If not following the link, the `file` is opened, but
there can't be interaction with the version control (magit) and thus I
like the default behavior to be follow the links.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Projectile

As switching between projects becomes more and more cumbersome, I
decided to finally head over to projectile and give it a try.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :ensure helm-projectile
    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t
          projectile-switch-project-action 'projectile-dired
          )

    )

#+END_SRC

#+RESULTS:
: t

* Communication
** Mail

At work I am using mutt for handling my emails, mostly because the
accessibility to all the other buffers I have opened and in part also
because I am using a en_US keyboard layout which can be kind of
problematic in official german emails. I used mutt for quite some time
now and I just found out, that I don't use the appropriate mode for my
emails. Let's fix that.

[[https://www.emacswiki.org/emacs/MuttInEmacs][Emacs Wiki]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '(".*mutt.*" . message-mode))
  (setq mail-header-separator "")
  (add-hook 'message-mode-hook
	    'turn-on-auto-fill
	    (function
	     (lambda ()
	       (progn
		 (local-unset-key "\C-c\C-c")
		 (define-key message-mode-map "\C-c\C-c" '(lambda ()
							    "save and exit quickly"
							    (interactive)
							    (save-buffer)))))))
#+END_SRC

#+RESULTS:
| turn-on-auto-fill |

Aaaand, it would be gread to use org tables in mails as well.

#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
  (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

** circe

For work, I'd like to use an emacs IRC client. If it prooves to be
good, I will switch to it generally.

#+BEGIN_SRC emacs-lisp :eval no
  (use-package circe
    :ensure t
    :config
    (setq circe-network-options
          `((,work-irc-server
           :tls nil
           :port 6667
           :nick "martin"
           :channels (,work-irc-channel)
           ))))
#+END_SRC

#+RESULTS:
: t

* Learning


* Startup

Testing some scripts for startup

#+BEGIN_SRC sh
  #!/bin/bash

  #set -x

  CG=$HOME/git/CG_bitbucket
  GH=$HOME/github

  err () {
      notify-send "$1"
      exit 1
  }

  REPOSITORIES="\
                   $CG/eudyptula \
                   $CG/org \
                   $CG/misc \
                   $CG/opencv-testbed \
                   $GH/emacs-org \
                   $GH/algorithms \
                   $GH/psp \
                   $GH/psp4android \
                   $GH/thelinuxprogramminginterface \
  "

  for repo in $REPOSITORIES; do
      if [ ! -d $repo ]; then
	  err "repo $(basename $repo) is not available"
      fi

      # execute everything in a subshell, may be useful later on
      (
	  cd $repo

	  status=$(git status -s)
	  if [ "y$status" != "y" ]; then
	      # can be unstaged or untracked
	      if [ $(expr match "$status" '^??.*') -eq 0 ]; then  # if unstaged
		  err "$(basename $repo) has unstaged changes"
	      fi
	  fi

	  git status | grep -e behind >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pulling changeds from $repo"
	      {
		  git pull
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to pull repo $repo"
	      fi
	  fi

	  git status | grep -e ahead >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pushing changes to $repo"
	      {
		  git push
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to push repo $repo"
	      fi
	  fi
      )
  done
#+END_SRC

#+RESULTS:

* Ledger

I use ledger to collect any accounting data.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t)

  (setenv "PATH" (concat (concat "/home/" user-login-name "/bin:")
			 (getenv "PATH")))
  (push (concat "/home/" user-login-name "/bin") exec-path)
#+END_SRC

(getenv "PATH")
#+RESULTS:

* Org-Mode
** General

As the most awesome people do, I too use org-mode! :)

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (setq org-log-done 'time)
    (setq org-clock-report-include-clocking-task t)
    :config
    (add-hook 'org-clock-in-hook 'martin/org-clock-in-set-state-to-started)
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (eval-after-load 'org-agenda
      '(bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
    (setq org-hide-emphasis-markers t
          org-src-window-setup 'current-window)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)
       (shell . t)
       (js . t)
       (python . t)
       (C . t)
       (css . t)
       (dot . t)
       (plantuml . t)
       (emacs-lisp . t)))
    )

  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
    (setq
     ;org-bullets-bullet-list '("✙" "♱" "♰" "☥" "✞" "✟" "✝" "†" "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥")
          org-ellipsis "➔"))
  #+END_SRC

#+RESULTS:
: t

Using actual circular bullets for bullet lists

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

#+RESULTS:

** Taking Notes

Setting the directories for the notes to be placed in - this will be
synced soonish.

#+BEGIN_SRC emacs-lisp
  (setq org-directory (concat (getenv "HOME") "/git/CG_bitbucket/org"))
  (setq org-default-notes-file (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org"))
#+END_SRC

#+RESULTS:
: ~/git/org/personal.org

*** Templates

Let's use =org-capture= to quickly add the things that come to mind all the time :)

#+BEGIN_SRC emacs-lisp
  (defvar martin/org-project-template "* %^{Project Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00|8:00}
  :END:
  SCHEDULED: %^t
  Why? %?
  What?
  Who?
  Where?
  How?
  Outcome?
  ,** Brainstorming
    Collect 10 Ideas
  " "Full Project Description")
  (defvar martin/org-basic-task-template "* TODO %^{Task}
  SCHEDULED: %^t
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00}
  :END:
  %?
  " "Basic task data")
  (defvar martin/org-programming-workout-template "* %^{Workout Description}
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25}
  :END:
  %^g%?
  " "Programming Workout Template")
  (defvar martin/org-journal-template
    "**** %^{Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25|0:30|0:45|1:00|2:00|4:00|8:00}
  :END:
  %T"
    "Journal Template")
  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org") "INBOX")
           ,martin/org-basic-task-template)
          ("T" "Quick Task" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org") "INBOX")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("j" "Journal entry" plain
           (file+datetree (concat (getenv "HOME") "/git/CG_bitbucket/org/journal.org")
           ,martin/org-journal-template
           :immediate-finish t))
          ("a" "Appointments" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/organizer.org") "Appointments")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org") "Decisions")
           "* %?\n%i")
          ("p" "Project" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org") "Projects")
           ,martin/org-project-template)
          ("W" "Workout" entry
           (file+headline (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org") "Primary Skills")
           ,martin/org-programming-workout-template)))
  (bind-key "C-M-r" 'org-capture)
#+END_SRC

#+RESULTS:
: org-capture

*** Refiling

=org-refile= lets you organize notes by typing in the headline to file
them under.

#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-entry nil)
#+END_SRC

#+RESULTS:


** Managing Tasks

*** Track TODO state

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"   ; next action
           "TOBLOG(b)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foregound "gray" :weight bold))))
#+END_SRC

#+RESULTS:
| TODO    | :foreground | green | :weight | bold |
| DONE    | :foreground | cyan  | :weight | bold |
| WAITING | :foreground | red   | :weight | bold |
| SOMEDAY | :foregound  | gray  | :weight | bold |

*** Tag Tasks with GTD-ish contexts

This defines the key commands for those, too.

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("call" . ?c)
                        ("@computer" . ?l)
                        ("@home" . ?h)
                        ("errand" . ?e)
                        ("@office" . ?o)
                        ("@anywhere" . ?a)
                        ("meetings" . ?m)
                        ("readreview" . ?r)
                        ("writing" . ?w)
                        ("programming" . ?p)
                        ("short" . ?s)
                        ("quantified" . ?q)
                        ("highenergy" . ?1)
                        ("lowenergy" . ?0)
                        ("business" . ?B)))
#+END_SRC

#+RESULTS:

*** Enable Filtering by Effort Estimates

That way it is easy to see short tasks that i can finish fast

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-global-properties
               '("Effort_ALL" . "0:05 0:10 0:15 0:20 0:25 0:30 0:45 1:00 2:00 4:00"))
#+END_SRC

#+RESULTS:

*** Habits

#+BEGIN_SRC emacs-lisp
  (setq org-habit-graph-column 80)
  (setq org-habit-show-habits-only-for-today nil)
#+END_SRC

#+RESULTS:

*** Estimating Tasks

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-clock-in-prepare-hook
            'martin/org-mode-ask-effort)
  (defun martin/org-mode-ask-effort ()
    "Ask for an effort estimate when clocking in."
    (unless (org-entry-get (point) "Effort")
      (let ((effort
             (completing-read
              "Effort: "
              (org-entry-get-multivalued-property (point) "Effort"))))
        (unless (equal effort "")
          (org-set-property "Effort" effort)))))
#+END_SRC

#+RESULTS:
: martin/org-mode-ask-effort

** Org Agenda

*** Basic Configuration
#+BEGIN_SRC emacs-lisp
  (setq my-org-agenda-files-list (list (concat (getenv "HOME") "/git/CG_bitbucket/org/personal.org")
				       (concat (getenv "HOME") "/git/CG_bitbucket/org/work.org")
				       (concat (getenv "HOME") "/git/CG_bitbucket/org/journal.org")
				       (concat (getenv "HOME") "/git/CG_bitbucket/org/organizer.org"))
	org-agenda-files
	(delq nil
	      (mapcar (lambda (x) (and (file-exists-p x) x))
		      my-org-agenda-files-list)))
#+END_SRC

#+RESULTS:
| /home/martin/git/CG_bitbucket/org/personal.org | /home/martin/git/CG_bitbucket/org/work.org | /home/martin/git/CG_bitbucket/org/journal.org | /home/martin/git/CG_bitbucket/org/organizer.org |

This is some configuration of Sacha's
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 2)
  (setq org-agenda-sticky nil)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          "-------------"
          (800 1000 1200 1400 1600 1800)))
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+END_SRC

#+RESULTS:
: %50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS

** Literate Programming

For syntax highlighting of org src blocks and disabling the
confirmation of executing those blocks the following variables are set

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil
	org-src-fontify-natively t
	org-src-tab-acts-natively t)
#+END_SRC

#+RESULTS:
: t

* Programming
** General

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    (require 'auto-complete-config)
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

#+RESULTS:
: t

** rtags

Build rtags first

#+BEGIN_SRC sh :var path="/opt/rtags"
  cd $path
  git clone --recursive https://github.com/Andersbakken/rtags.git
  cd rtags
  cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 .
  make
#+END_SRC

Integrate in systemd

#+BEGIN_SRC conf :file ~/.config/systemd/user/rdm.socket
  [Unit]
  Description=RTags daemon socket

  [Socket]
  ListenStream=%t/rdm.socket

  [Install]
  WantedBy=default.target
#+END_SRC

#+BEGIN_SRC conf :file ~/.config/systemd/user/rdm.service
  [Unit]
  Description=RTags daemon

  Requires=rdm.socket

  [Service]
  Type=simple
  ExecStart=$RDM -v --inactivity-timeout 300 --log-flush
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package rtags
    :ensure t
    :config
    (use-package flycheck-rtags
      :ensure t)

    (use-package ac-rtags
      :ensure t)

    (use-package helm-rtags
      :ensure t)
    )
#+END_SRC

#+RESULTS:
: t

** C

Linux kernel coding style adjustments

#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only ()
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
	 c-basic-offset)))

  (defun my/general-c-mode-configuration ()
    (setq indent-tabs-mode t)
    (setq show-trailing-whitespace t
          c-basic-offset 8
          cdefault-style "linux"
          tab-width 8
          indent-tabs-mode t
	  show-trailing-whitespace t
	  c-set-style "linux-tabs-only"))
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))

  (semantic-mode 1)
  (defun my/add-semantic-to-autocomplete ()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (add-hook 'c-mode-common-hook 'my/add-semantic-to-autocomplete)
  (add-hook 'c-mode-common-hook 'my/general-c-mode-configuration)
  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))
#+END_SRC

#+RESULTS:
| my/add-semantic-to-autocomplete |

Define a function that intializes auto-complete-c-headers and gets
called for c/c++ hooks

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete-c-headers
    :ensure t
    :config
    (add-to-list 'ac-sources 'ac-source-c-headers))

  (defun my/init-ac-c-headers ()
    (require 'auto-complete-c-headers)
    (add-to-list 'achead:include-directories '"/usr/src/linux/include/"))

  (add-hook 'c++-mode-hook 'my/init-ac-c-headers)
  (add-hook 'c-mode-hook 'my/init-ac-c-headers)
#+END_SRC

#+RESULTS:
| my/init-ac-c-headers |

Use iedit for refactoring

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :config
    (define-key global-map (kbd "C-c ;") 'iedit-mode))
#+END_SRC

#+RESULTS:
: t

Use flycheck for syntax checking

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure flycheck-cstyle
    :config
    (eval-after-load 'flycheck
      '(progn
         (require 'flycheck-cstyle)
         (flycheck-cstyle-setup)
         (flycheck-add-next-checker 'c/c++-cppcheck '(warning . cstyle))))
    (global-flycheck-mode)
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-include-path
                               (list "/usr/src/linux/include" ))))
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-language-standard "c11"))))
#+END_SRC

#+RESULTS:
: t

Highlight TODO/FIXME/etc

#+BEGIN_SRC emacs-lisp
  (defun my-highlight-keywords-warning()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(FIXME\\|TODO\\|XXX+\\|BUG\\):"
			       1 font-lock-warning-face prepend))))
  (defun my-highlight-keywords-info()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(NOTE\\|INFO\\|\\):"
			       1 font-lock-comment-face prepend))))

  (add-hook 'c-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c-mode-hook 'my-highlight-keywords-info)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-info)
#+END_SRC

#+RESULTS:
| my-highlight-keywords-info | my-highlight-keywords-warning | fix-enum-class | my-highlight-keywords | my/init-ac-c-headers |

** C++
*** Indentation enum class

This indentation is not working in the original c++-mode, thus a fix is needed:

#+BEGIN_SRC emacs-lisp
  (defun inside-class-enum-p (pos)
    "Checks if POS is within the braces of a C++ \"enum class\"."
    (ignore-errors
      (save-excursion
	(goto-char pos)
	(up-list -1)
	(backward-sexp 1)
	(looking-back "enum[ \t]+class[ \t]+[^}]+"))))

  (defun align-enum-class (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	(c-lineup-topmost-intro-cont langelem)))

  (defun align-enum-class-closing-brace (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	'-
      '+))

  (defun fix-enum-class ()
    "Setup `c++-mode' to better handle \"class enum\"."
    (add-to-list 'c-offsets-alist '(topmost-intro-cont . align-enum-class))
    (add-to-list 'c-offsets-alist
		 '(statement-cont . align-enum-class-closing-brace)))

  (add-hook 'c++-mode-hook 'fix-enum-class)
#+END_SRC

#+RESULTS:
| fix-enum-class | my/init-ac-c-headers |

** Linux
*** dts mode

After some time digging through device tree files it is time to use an
appropriate mode..

#+BEGIN_SRC emacs-lisp
  (use-package dts-mode
    :ensure t)
#+END_SRC

#+RESULTS:


** WebDev

For work I need some php/javascript combination support. Web-mode
gives me what I need so far.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (defun my-setup-php ()
      ;; enable web mode
      (web-mode)

      ;; make these variables local
      (make-local-variable 'web-mode-code-indent-offset)
      (make-local-variable 'web-mode-markup-indent-offset)
      (make-local-variable 'web-mode-css-indent-offset)

      ;; set indentation, can set different indentation level for different code type
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-markup-indent-offset 2))
    (add-to-list 'auto-mode-alist '("\\.php$" . my-setup-php))
    )
#+END_SRC

#+RESULTS:
: t

I started coding Javascript lately and thus an appropriate mode is
needed. [[http://truongtx.me][Truong TX]] gave a nice example.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))

  (use-package js2-mode
    :ensure t
    :init
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (setq js2-highlight-level 3))

  (use-package ac-js2
    :ensure t
    :init
    (add-hook 'js2-mode-hook 'ac-js2-mode))


  (use-package flymake-jslint
    :ensure t
    :config
    (add-to-list 'load-path (concat (getenv "HOME") "/git/lintnode"))
    (setq lintnode-location (concat (getenv "HOME") "/git/lintnode"))
    (setq lintnode-jslint-excludes (list 'nomen 'undef 'plusplus 'onevar 'white))
    (add-hook 'js-mode-hook
	      (lambda()
		(lintnode-hook))))
#+END_SRC

#+RESULTS:
: t

** Common Lisp

I learned to love slime really quickly.

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t)

  (setq inferior-lisp-program "/usr/bin/clisp")
#+END_SRC
