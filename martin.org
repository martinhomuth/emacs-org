#+TITLE Literate Emacs Configuration
#+AUTHOR: Martin Homuth
#+EMAIL: martin@followthestack.tech

Inspired by [[https://protesilaos.com/][Protesilaos Stavrou]] I changed my Emacs configuration to a
literate configuration. That especially includes a structuring process
allowing me to clean up the files to be generated. This file is the
source of the new setup which is then tangled into the sub structures
as follows

- early-init.el
- init.el
- mh-modules
- mh-lisp

* Structural Commands

To ensure the modules are loaded properly, they need to be adeed to
the load path and all modules have to be required. For now we
explicitly require them, but in the future I'd like to have a macro
for it to automatically obtain the provisioning and requirement via
the =init.el=.

  #+begin_src emacs-lisp :tangle "init.el"
    (mapc
     (lambda (string)
       (add-to-list 'load-path (locate-user-emacs-file string)))
     '("mh-lisp" "mh-modules"))
  #+end_src

  #+RESULTS:
  | mh-lisp | mh-modules |

Also I want to make sure that this file is always tangled as soon as
it is saved.

#+begin_src emacs-lisp
  (defun mh--tangle-this-file()
    """
     Tangles this buffers file.
    """
    (org-babel-tangle-file (buffer-file-name (current-buffer))))

  (add-hook 'after-save-hook 'mh--tangle-this-file nil t)
#+end_src

#+RESULTS:
| mh--tangle-this-file | flycheck-handle-save | t |

* Personal Information

If for some reason any application will need personal information,
here they are ;-)

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq user-full-name "Martin Homuth")
#+END_SRC

#+RESULTS:
: Martin Homuth

Load all the things I don't like to share with the world or think is
better be extracted from this file.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (let ((file (expand-file-name "~/.emacs.d/secrets.el")))
    (if (file-exists-p file)
        (load file)))
#+END_SRC

#+RESULTS:
: t

And configure some custom stuff that is also based on the system emacs
pis running on. There are four systems that I consider:
 1. Desktop (melchior)
 2. Work Desktop (devpool16)
 3. Work Laptop (mobilepool16)
 4. Any other system (servers)

#+begin_src emacs-lisp :tangle "init.el"
  ;;; mail address based on username
  (setq user-mail-address
        (let ((username (getenv "USER")))
          (cond ((string= username "martin") "martin@followthestack.tech")
                ((string= username "mhomuth") "mh@emlix.com")
                "martin@followthestack.tech")))

  ;;; fontsize based on screen resolution
  (if (display-graphic-p)
      (setq fontsize
            (let ((width (x-display-pixel-width)))
              (cond ((eql width 6336) 10) ;;; 2 monitor workstation in office
                    (t 9)))))

#+end_src

* Emacs Initialization

These settings are for emacs internals, nothing specific.

** the =early-init.el= file

Just to make sure specific things are loaded as soon as possible

#+begin_src emacs-lisp :tangle early-init.el
  (setq custom-file (expand-file-name "custom.el" (concat (getenv "HOME") "/.emacs.d/")))
  (when (file-exists-p custom-file)
    (load custom-file))

  (add-to-list 'load-path "~/elisp/org-mode/lisp")
  (add-to-list 'load-path "~/elisp/org-mode/contrib/lisp")
  (add-to-list 'load-path "/usr/share/emacs/site-lisp")

  (mapc
   (lambda (string)
     (add-to-list 'load-path (locate-user-emacs-file string)))
   '("mh-lisp" "mh-modules"))
#+end_src

** the final =init.el= call to submodules

#+begin_src emacs-lisp :tangle "init.el"
  (require 'mh-org)
#+end_src

** add Package Sources

Use additional sources for the packages, and ensure that use-package
is available

   #+BEGIN_SRC emacs-lisp :tangle early-init.el
     (setq package-archives
           '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
             ("nongnu" . "https://elpa.nongnu.org/nongnu/")
             ("melpa" . "https://melpa.org/packages/")))

     ;; Highest number gets priority (what is not mentioned has priority 0)
     (setq package-archive-priorities
           '(("gnu-elpa" . 3)
             ("melpa" . 2)
             ("nongnu" . 1)))

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))
     (eval-when-compile
       (require 'use-package))

     ;; also keep the packages up to date
     (use-package auto-package-update
       :ensure t
       :config
       (setq auto-package-update-delete-old-versions t)
       (setq auto-package-update-hide-results t)
       (auto-package-update-maybe))
   #+END_SRC

** Emacs Fonts and Locale

I guess I set fonts manually.. Maybe there is a better way for this.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  ;; TODO: add default font and fontsize
  (when (boundp 'fontsize)
    (add-to-list 'default-frame-alist
                 `(font . ,(concat "Source Code Pro-" (number-to-string fontsize)))
                 `(font . ,(concat "Noto Color Emoji" (number-to-string fontsize)))
                 ))

    ;; Treat clipboard as UTF-8 string first
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

  ;; see https://github.com/rolandwalker/unicode-fonts
  (use-package unicode-fonts
    :ensure t
    :config
    (unicode-fonts-setup))
#+END_SRC

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |

** Frame Position and Size

TODO: add configuration that is different accross all devices

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (progn
    (setq initial-frame-alist '( (tool-bar-lines . 0)))
    (if (window-system)
        (nconc initial-frame-alist
              '(
                (width . 230) ; chars
                (height . 60) ; lines
                (left . 1261)
                (top . 514))))
    (setq default-frame-alist '( (tool-bar-lines . 0)))
    (if (window-system)
        (nconc default-frame-alist
              '(
                (width . 230) ; chars
                (height . 60) ; lines
                (left . 1261)
                (top . 514))))
  )
#+END_SRC

** Window Handling

As of yet I never tried understanding how window positioning and
sizing works by default. Thanks to [[https://www.youtube.com/watch?v=-H2nU0rsUMY][System Crafters]] I started to
understand it a bit more, this is the first step towards a fully
customized setup that fits my needs - and before I dive into the
manual.

#+begin_src emacs-lisp :tangle "init.el"
  (setq display-buffer-base-action
        '((display-buffer-reuse-window
           display-buffer-reuse-mode-window
           display-buffer-same-window
           display-buffer-in-previous-window)
          . ((mode . (org-mode helpful-mode help-mode)))))
#+end_src

** Simple Terminal (st) fixup

With st I experienced a rather large delay when opening files with
emacsclient that initially showed some other buffer before switching
to the desired file. The following hack should prevent this, for
whatever reason.

#+begin_src emacs-lisp :tangle "init.el"
  (if (not (assoc "xterm-256color" term-file-aliases))
      (setq term-file-aliases (cons '("xterm-256color" . "rxvt")
                                    term-file-aliases)))
  (if (not (assoc "st" term-file-aliases))
      (setq term-file-aliases (cons '("st" . "xterm-256color")
                                    term-file-aliases)))

#+end_src

** Themes

For now I use the same theme for all my machines. This will be
refactored later for allowing different themes.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (unless (package-installed-p 'gruvbox-theme)
    (package-refresh-contents)
    (package-install 'gruvbox-theme))
  (load-theme 'gruvbox t)
  (setq-default cursor-type 'box)
#+END_SRC

#+RESULTS:
: t

** Emacs-Server

Starting the server at emacs start should be handy someday..

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (if (or (not (fboundp 'server-running-p))
          (not (server-running-p)))
      (server-start))
#+END_SRC

#+RESULTS:

** Backup

The file backups emacs uses are pretty annoying, so I place them in a
separate directory instead of next to the file in use. If needed these
files are accessible there quite easily.

If this variable is nil, or it fails to match a filename, the backup
is made in the original file's directory. This is what I really don't
want.

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

** Auto-Revert

I am working with different computers on the same text base controlled
by git and some background jobs that keep the git repositories current
by some means. As the files are always opened and essential to my
organization, I need to make sure that the opened buffers are current
all the time. Apparantly global-auto-revert-mode does the trick.

#+begin_src emacs-lisp :tangle "init.el"
  (global-auto-revert-mode)
#+end_src

#+RESULTS:
: t

** Auto-Compile

Enable auto compilation to ensure to never load out of date lisp modules

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package auto-compile
    :ensure t
    :init (setq load-prefer-newer t)
    :config
    (auto-compile-on-load-mode)
    (auto-compile-on-save-mode))
#+END_SRC

#+RESULTS:
: t

** General Configuration

#+BEGIN_SRC emacs-lisp :tangle early-init.el
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (line-number-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (delete-selection-mode t)
  (show-paren-mode 1)

  (setq fill-column 85
        initial-scratch-message ""
        show-paren-delay 0
        show-paren-style 'mixed
        visible-bell t
        browse-url-browser-function 'browse-url-chromium
        browse-url-new-window-flag  t
        browse-url-firefox-new-window-is-tab t)

  ;; Whitespaces... A colleague of mine showed me the horror of not
  ;; considering whitespaces and thus they are shown always and everywhere!
  (setq-default show-trailing-whitespace t)
#+END_SRC

#+RESULTS:
: t

A good addition is to toggle every whitespace character on demand.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (global-set-key (kbd "C-c T w") 'whitespace-mode)
  (setq whitespace-line-column nil
        whitespace-display-mappings '((space-mark 32 [183] [46])
                                      (newline-mark 10 [9166 10])
                                      (tab-mark 9 [9654 9] [92 9])))
#+END_SRC

#+RESULTS:

** Ivy

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package counsel
    :ensure t)
  (use-package ivy :ensure t
    :diminish (ivy-mode . "")
    :config
    (ivy-mode 1)
    ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; number of result lines to display
    (setq ivy-height 10)
    ;; does not count candidates
    (setq ivy-count-format "(%d/%d) ")
    ;; no regexp by default
    (setq ivy-initial-inputs-alist nil)
    ;; configure regexp engine.
    (setq ivy-re-builders-alist
          ;; allow input not in order
          '((t   . ivy--regex-ignore-order)))
    (setq swiper-stay-on-quit t)
    :bind (("C-s" . 'swiper)
           ("C-r" . 'swiper)
           ("M-x" . 'counsel-M-x)
           ("C-x C-f" . 'counsel-find-file)
           ("M-y" . 'counsel-yank-pop)
           ("C-h a" . 'counsel-apropos)
           ("C-h v" . 'counsel-describe-variable)
           ("C-h f" . 'counsel-describe-function)
           ("C-h u" . 'counsel-unicode-char)
           ("C-x b" . 'counsel-switch-buffer)
           ("C-c j" . 'counsel-git-grep)
           ("C-c L" . 'counsel-git-log)
           ))
  (use-package ivy-hydra
    :ensure t
    :after (ivy hydra))
#+END_SRC

#+RESULTS:

** Hydra

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package hydra
    :ensure ace-window
    :ensure hydra
    :init
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window ()
       "window"
       ("v" (\lambda ()
             (interactive)
             (split-window-right)
             (other-window 1))
        "vert")
       ("x" (\lambda ()
             (interactive)
             (split-window-below)
             (other-window 1))
        "horz")
       ("t" transpose-frame "'")
       ("o" delete-other-windows "one" :color blue)
       ("a" ace-window "ace")
       ("s" ace-swap-window "swap")
       ("d" ace-delete-window "del")
       ("i" ace-maximize-window "ace-one" :color blue)
       ("b" switch-to-buffer "buf")
       ("m" headlong-bookmark-jump "bmk")
       ("q" nil "cancel"))))
#+END_SRC

#+RESULTS:

** Exit Confirmation

Even though unsaved buffers saved me lots of times due to prompting
for save, it happened quite often that I closed Emacs because of
mistyping. Maybe a confirmation helps and is not really annoying -
when in window system.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun martin-save-buffers-kill-emacs-with-confirm ()
    "Thanks to jsled for this method"
    (interactive)
    (if (window-system)
	(if (null current-prefix-arg)
	    (if (y-or-n-p "Are you sure you want to quit?")
		(save-buffers-kill-emacs))
	  (save-buffers-kill-emacs))
      (save-buffers-kill-terminal)))
  (global-set-key "\C-x\C-c" 'martin-save-buffers-kill-emacs-with-confirm)
#+END_SRC

#+RESULTS:
: martin-save-buffers-kill-emacs-with-confirm

** Beacon

Instead of using my own stuff, switch to beacon mode as it looks very
promising.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1))
#+end_src

#+RESULTS:
: t

** Snippets

From Sacha Chuas Configuration for testing

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode ;; used to remove mode line information that is not used
    :init (yas-global-mode)
    :config
    (progn
      (yas-global-mode)
      (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
      (setq yas-key-syntaxes '("w_" "w_." "^ "))
      (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
      (setq yas-expand-only-for-last-commands nil)
      (yas-global-mode 1)
      (bind-key "\t" 'hippie-expand yas-minor-mode-map)))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq default-cursor-color "gray")
  (setq yasnippet-can-fire-cursor-color "purple")

  ;; It will test whether it can expand, if yes, cursor color -> green.
  (defun yasnippet-can-fire-p (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
	(setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
							(yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (and templates-and-pos (first templates-and-pos))))

  (defun my/change-cursor-color-when-can-expand (&optional field)
    (interactive)
    (when (eq last-command 'self-insert-command)
      (set-cursor-color (if (my/can-expand)
                            yasnippet-can-fire-cursor-color
                          default-cursor-color))))

  (defun my/can-expand ()
    "Return true if right after an expandable thing."
    (or (abbrev--before-point) (yasnippet-can-fire-p)))

  (add-hook 'post-command-hook 'my/change-cursor-color-when-can-expand)

  (defun my/insert-space-or-expand ()
    "For binding to the SPC SPC keychord."
    (interactive)
    (condition-case nil (or (my/hippie-expand-maybe nil) (insert "  "))))
#+END_SRC

#+RESULTS:
: my/insert-space-or-expand

** Dashboard

#+BEGIN_SRC emacs-lisp :tangle no
  (defun mh-dashboard-insert-inbox (list-size)
    "Add the list of LIST-SIZE items of inbox items"
    (require 'org)
    (let ((org-files (org-files-list)))
      (dashboard-insert-section "INBOX: " nil list-size "i" nil nil)))

  (defun mh-idle-switch-to-dashboard()
    (interactive)
    (switch-to-buffer "*dashboard*")
    (dashboard-refresh-buffer)
    (delete-other-windows))

  (use-package all-the-icons
    :ensure t)

  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
          dashboard-items '((inbox . 20)
                            (agenda . 10)
                            (projects . 5)
                            (bookmarks . 5))
          dashboard-center-content t
          dashboard-set-heading-icons t
          dashboard-set-file-icons t
          dashboard-set-navigator t)

    (add-to-list 'dashboard-item-generators '(inbox . mh-dashboard-insert-inbox))

    (run-with-idle-timer 300 t 'mh-idle-switch-to-dashboard))
#+END_SRC

#+RESULTS:
: t

** Timeclock

Tracking time in a different way than before. Lets use
timeclock.el. Connecting `display-time-mode` to this functionality
might not be the best way, but for now I think that fits only here
well.

#+begin_src emacs-lisp :tangle "init.el"
  (use-package timeclock
    :ensure t
    :init
    (display-time-mode)
    (timeclock-mode-line-display)
    :config
    (define-key ctl-x-map "ti" 'timeclock-in)
    (define-key ctl-x-map "to" 'timeclock-out)
    (define-key ctl-x-map "tc" 'timeclock-change)
    (define-key ctl-x-map "tr" 'timeclock-reread-log)
    (define-key ctl-x-map "tu" 'timeclock-update-mode-line)
    (define-key ctl-x-map "tw" 'timeclock-when-to-leave-string)
    (define-key ctl-x-map "tR" 'timeclock-generate-report)
    (add-hook 'kill-emacs-query-functions #'timeclock-query-out)
    (setq timeclock-file "~/Nextcloud/work/timelog"
          display-time-load-average nil
          timeclock-relative nil))
#+end_src

#+RESULTS:
: t

** Key Bindings
#+BEGIN_SRC emacs-lisp :tangle "init.el"
  ;; General
  (global-set-key "\C-cw" 'compare-windows)
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  (global-set-key (kbd "C-M-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward-regexp)
  (global-unset-key (kbd "C-z")) ;; who needs that anyways?
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "M-O") 'mh-prev-other-window)
  (global-unset-key "\C-xf")
  (global-set-key [f1] 'eshell)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x b") 'magit-blame-echo)
  (global-set-key (kbd "C-x C-b") 'switch-to-buffer)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "C-c o") 'ff-find-other-file)
  (global-set-key (kbd "C-x r l") 'counsel-bookmark)
  ;; Org-Mode
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c O" 'org-open-at-point-global)
  (bind-key "<f9>" 'org-agenda-list)

  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "M-c") 'capitalize-dwim)
#+END_SRC

#+RESULTS:
: capitalize-dwim

#+END_SRC

#+RESULTS:
: magit-status


* Ediff

Make sure ediff does not spawn another frame.

#+begin_src emacs-lisp :tangle "init.el"
  (setq ediff-split-window-function 'split-window-horizontally
        ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

#+RESULTS:
: ediff-setup-windows-plain

And ensure that the colors do not work against me when using the
gruvbox theme.

#+begin_src emacs-lisp :tangle "init.el"
  (custom-set-faces
   '(ediff-current-diff-A ((t (:foreground "Black"))))
   '(ediff-fine-diff-A ((t (:foreground "Black"))))
   '(ediff-current-diff-B ((t (:foreground "Black"))))
   '(ediff-fine-diff-B ((t (:foreground "Black"))))
   '(ediff-current-diff-C ((t (:foreground "Black"))))
   '(ediff-fine-diff-C ((t (:foreground "Black")))))
#+end_src

#+RESULTS:

* Pomodoro Timer

I am using the pomodoro technique for focus sessions and the org-mode
built-in timer gives me all the things that I need. So first we are
defining the required keybinds:

#+begin_src emacs-lisp :tangle "init.el"
  (global-set-key (kbd "C-x p i") 'mh-pomodoro-start-focus)
  (global-set-key (kbd "C-x p b") 'mh-pomodoro-start-break)
  (global-set-key (kbd "C-x p o") 'mh-pomodoro-stop)
  (global-set-key (kbd "C-x p r") 'mh-pomodoro-remaining-time)
#+end_src

Then we need the functions of course. Starting the focus period (as
well as all other functions) are based on 'org-timer-set-timer with
a predefined value for a pomodoro: 25 minutes. It should also notify
me additionally about the timer being started, similarly as it
notifies me about the finished timer:

#+begin_src emacs-lisp :tangle "init.el"
  (require 'notifications)
  (defun mh-pomodoro-start-focus()
    """ Starts a focus period """
    (interactive)
    (let ((focus-period 25))
      (notifications-notify
       :title "Focus period started"
       :on-action 'mh-pomodoro-start-focus
       :timeout 1500
       )

      (org-timer-set-timer focus-period)))
#+end_src

A break is basically the same with only 5 minutes to go.

#+begin_src emacs-lisp :tangle "init.el"
  (defun mh-pomodoro-start-break()
    """ Starts a break period """
    (interactive)
    (let ((break-period 5))
      (notifications-notify
       :title "Break period started"
       :on-action 'mh-pomodoro-start-focus
       :timeout 1500
       )
      (org-timer-set-timer break-period)))
#+end_src

And finally to stop the timer, we use the appropriate function

#+begin_src emacs-lisp :tangle "init.el"
  (defun mh-pomodoro-stop()
    """ Stops the pomodoro timer """
    (interactive)
    (notifications-notify
     :title "Pomodoro Timer stopped"
     :on-action 'mh-pomodoro-start-focus
     :timeout 1500
     )
    (org-timer-stop))
#+end_src

As having timer is nice and all, a little bit more feedback is
required. I simply use some downloaded bell sound for that, which is
stored in the nextcloud thus available on all machines.

#+begin_src emacs-lisp :tangle "init.el"
  (setq org-clock-sound "~/Nextcloud/Martin/bell.wav")
#+end_src

In between sessions it is also helpful to be able to obtain the
current remaining time. This should be retrievable and also notified
to the system.

#+begin_src emacs-lisp :tangle "init.el"
  (defun mh-pomodoro-remaining-time()
    """ Reports the remaining time """
    (interactive)
    (let ((remaining-time (org-timer-show-remaining-time)))
      (notifications-notify
       :title "Remaining time"
       :body remaining-time
       :timeout 1500
       )))
#+end_src

* Blog

** org-publish

Thanks to [[https://diego.codes/post/blogging-with-org/][Diego Vicente]] for his post on blogging with emacs as a
starting point. For the time being I'm going to go with his
configuration until the blog is somewhat running.

#+BEGIN_SRC emacs-lisp
  (use-package ox-publish
    :init

    (setq my-blog-header-file "~/blogtest/org/partials/header.html"
          my-blog-footer-file "~/blogtest/org/partials/footer.html"
          org-html-validation-link nil)

    ;; Load partials on memory
    (defun my-blog-header (arg)
      (with-temp-buffer
        (insert-file-contents my-blog-header-file)
        (buffer-string)))

    (defun my-blog-footer (arg)
      (with-temp-buffer
        (insert-file-contents my-blog-footer-file)
        (buffer-string)))

    (defun filter-local-links (link backend info)
      "Filter that converts all the /index.html links to /"
      (if (org-export-derived-backend-p backend 'html)
          (replace-regexp-in-string "/index.html" "/" link)))

    (setq org-publish-project-alist
          '(("blog-notes"
             :base-directory "~/blogtest/org"
             :base-extension "org"
             :publishing-directory "~/blogtest/public"
             :recursive t
             :publishing-function org-html-publish-to-html
             :headline-levels 4
             :section-numbers nil
             :html-head nil
             :html-head-include-default-style nil
             :html-head-include-scripts nil
             :html-preamble my-blog-header
             :html-postamble my-blog-footer)

            ("blog-static"
             :base-directory "~/blogtest/org/"
             :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|eot\\|svg\\|woff\\|woff2\\|ttf"
             :publishing-directory "~/blogtest/public"
             :recursive t
             :publishing-function org-publish-attachment
             )

            ("blog" :components ("blog-notes" "blog-static")))))

    (add-to-list 'org-export-filter-link-functions 'filter-local-links)
#+END_SRC

#+RESULTS:
| filter-local-links |

* Navigation
** Better Beginning Of The Line

Thanks to Howard Abrams for this neat function!

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
  (global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line
** Previous other window

As there appears not to be any simple function to return to the
previous window instead of directly passing a negative argument to

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun mh-prev-other-window()
    "Simple function wrapper to `other-window' with a negative argument"
    (interactive)
     (other-window -1))
#+END_SRC

** Moving Files

Moving files using /rename-file/ or /dired-do-rename/ does not modify the
buffer of that file, which is not what I usually want. Taken from [[http://zck.me/emacs-move-file][here]]
is a method to not just rename the file but also the buffer associated
with the file.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (if buffer-file-name
			   (read-file-name "Move file to: ")
			 (read-file-name "Move file to: "
					 default-directory
					 (expand-file-name (file-name-nondirectory (buffer-name))
							   default-directory)))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (buffer-file-name)))
      (write-file new-location t)
      (when (and old-location
		 (file-exists-p new-location)
		 (not (string-equal old-location new-location)))
	(delete-file old-location))))

  (bind-key "C-x C-m" 'move-file)
#+END_SRC

** Dired

Handling dired buffers is kind of cumbersome for me, especially
because opening a folder means more buffers for every folder I
enter. This is not bad per se, but not really what I would
like. Following the great emacs news by Sacha Chua, I found [[http://xenodium.com/#drill-down-emacs-dired-with-dired-subtree][this]] on
reddit:

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (setq dired-subtree-use-backgrounds nil)
    (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))
#+END_SRC

#+RESULTS:
: t

* Editing
** yaml-mode

#+begin_src emacs-lisp :tangle "init.el"
  (use-package yaml-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.yml\\'" .  yaml-mode))
    (add-hook 'yaml-mode-hook
              '(lambda ()
                 (define-key yaml-mode-map "\C-m" 'newline-and-indent)))
    )
#+end_src

#+RESULTS:
: t

** Expand Region

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package expand-region
    :ensure t
    :commands ( er/expand-region er/contract-region )
    :bind ("M-r" . er/expand-region)
    :bind ("M-q" . er/contract-region)
    )
#+END_SRC

#+RESULTS:
: er/contract-region

** eshell

Eshell seems to be a great tool, but sometimes it is kind of
unhandy. There are two things that come to mind really quick:
1. whitespace mode when ls-ing
2. auto-completion tabs through the directories in the wrong order.
   This is due to the fact, that the completion uses the last-modified
   entry first. Basis for that is the function stored in
   "eshell-cmpl-compare-entry-function".
3. when re-entering eshell using <f1> the old position stays, I'd like
   the shell when entered with the key to change the wd to the buffer
   I entered the eshell with

Let's fix these things

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq show-trailing-whitespace nil)))

  (setq eshell-cmpl-compare-entry-function (quote string-lessp))
#+END_SRC

** bb-mode

Yocto Yocto Yocto

https://github.com/mferland/bb-mode

#+begin_src emacs-lisp :tangle "init.el"
  (add-to-list 'load-path "~/git/bb-mode")

  (require 'bb-mode)
  (setq auto-mode-alist (cons '("\\.bb$" . bb-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.inc$" . bb-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.bbappend$" . bb-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.bbclass$" . bb-mode) auto-mode-alist))
  (setq auto-mode-alist (cons '("\\.conf$" . bb-mode) auto-mode-alist))
#+end_src

#+RESULTS:
: ((\.conf$ . bb-mode) (\.bbclass$ . bb-mode) (\.bbappend$ . bb-mode) (\.inc$ . bb-mode) (\.bb$ . bb-mode) (\.odc\' . archive-mode) (\.odf\' . archive-mode) (\.odi\' . archive-mode) (\.otp\' . archive-mode) (\.odp\' . archive-mode) (\.otg\' . archive-mode) (\.odg\' . archive-mode) (\.ots\' . archive-mode) (\.ods\' . archive-mode) (\.odm\' . archive-mode) (\.ott\' . archive-mode) (\.odt\' . archive-mode) (^yang\.settings$ . jsonc-mode) (\.json$ . js-mode) (\.php$ . my-setup-php) (.*mutt.* . message-mode) (\.yml\' . yaml-mode) (\.proto\' . protobuf-mode) (\.po\'\|\.po\. . po-mode) (\.eselect\' . eselect-mode) (/make\.\(conf\|defaults\)\' . conf-unix-mode) (/\(package\.\(mask\|unmask\|use\|env\|license\|properties\|accept_\(keywords\|restrict\)\)\|\(package\.\)?use.\(stable\.\)?\(force\|mask\)\)\' . conf-space-mode) (/glep.*\.rst\' . glep-mode) (/[0-9]\{4\}-[01][0-9]-[0-3][0-9]-.+\.[a-z]\{2\}\.txt\' . gentoo-newsitem-mode) (/devmanual.*\.xml\' . devbook-mode) (\.eclass\' . ebuild-eclass-mode) (\.ebuild\' . ebuild-mode) (\.at\' . autotest-mode) (\.ac\'\|configure\.in\' . autoconf-mode) (\.dtsi?\' . dts-mode) (/git-rebase-todo\' . git-rebase-mode) (\.\(?:md\|markdown\|mkd\|mdown\|mkdn\|mdwn\)\' . markdown-mode) (\.\(e?ya?\|ra\)ml\' . yaml-mode) (\.gpg\(~\|\.~[0-9]+~\)?\' nil epa-file) (\.elc\' . elisp-byte-code-mode) (\.zst\' nil jka-compr) (\.dz\' nil jka-compr) (\.xz\' nil jka-compr) (\.lzma\' nil jka-compr) (\.lz\' nil jka-compr) (\.g?z\' nil jka-compr) (\.bz2\' nil jka-compr) (\.Z\' nil jka-compr) (\.vr[hi]?\' . vera-mode) (\(?:\.\(?:rbw?\|ru\|rake\|thor\|jbuilder\|rabl\|gemspec\|podspec\)\|/\(?:Gem\|Rake\|Cap\|Thor\|Puppet\|Berks\|Brew\|Vagrant\|Guard\|Pod\)file\)\' . ruby-mode) (\.re?st\' . rst-mode) (\.py[iw]?\' . python-mode) (\.m\' . octave-maybe-mode) (\.less\' . less-css-mode) (\.scss\' . scss-mode) (\.cs\' . csharp-mode) (\.awk\' . awk-mode) (\.\(u?lpc\|pike\|pmod\(\.in\)?\)\' . pike-mode) (\.idl\' . idl-mode) (\.java\' . java-mode) (\.m\' . objc-mode) (\.ii\' . c++-mode) (\.i\' . c-mode) (\.lex\' . c-mode) (\.y\(acc\)?\' . c-mode) (\.h\' . c-or-c++-mode) (\.c\' . c-mode) (\.\(CC?\|HH?\)\' . c++-mode) (\.[ch]\(pp\|xx\|\+\+\)\' . c++-mode) (\.\(cc\|hh\)\' . c++-mode) (\.\(bat\|cmd\)\' . bat-mode) (\.[sx]?html?\(\.[a-zA-Z_]+\)?\' . mhtml-mode) (\.svgz?\' . image-mode) (\.svgz?\' . xml-mode) (\.x[bp]m\' . image-mode) (\.x[bp]m\' . c-mode) (\.p[bpgn]m\' . image-mode) (\.tiff?\' . image-mode) (\.gif\' . image-mode) (\.png\' . image-mode) (\.jpe?g\' . image-mode) (\.webp\' . image-mode) (\.te?xt\' . text-mode) (\.[tT]e[xX]\' . tex-mode) (\.ins\' . tex-mode) (\.ltx\' . latex-mode) (\.dtx\' . doctex-mode) (\.org\' . org-mode) (\.dir-locals\(?:-2\)?\.el\' . lisp-data-mode) (\.eld\' . lisp-data-mode) (eww-bookmarks\' . lisp-data-mode) (tramp\' . lisp-data-mode) (/archive-contents\' . lisp-data-mode) (places\' . lisp-data-mode) (\.emacs-places\' . lisp-data-mode) (\.el\' . emacs-lisp-mode) (Project\.ede\' . emacs-lisp-mode) (\.\(scm\|sls\|sld\|stk\|ss\|sch\)\' . scheme-mode) (\.l\' . lisp-mode) (\.li?sp\' . lisp-mode) (\.[fF]\' . fortran-mode) (\.for\' . fortran-mode) (\.p\' . pascal-mode) (\.pas\' . pascal-mode) (\.\(dpr\|DPR\)\' . delphi-mode) (\.\([pP]\([Llm]\|erl\|od\)\|al\)\' . perl-mode) (Imakefile\' . makefile-imake-mode) (Makeppfile\(?:\.mk\)?\' . makefile-makepp-mode) (\.makepp\' . makefile-makepp-mode) (\.mk\' . makefile-gmake-mode) (\.make\' . makefile-gmake-mode) ([Mm]akefile\' . makefile-gmake-mode) (\.am\' . makefile-automake-mode) (\.texinfo\' . texinfo-mode) (\.te?xi\' . texinfo-mode) (\.[sS]\' . asm-mode) (\.asm\' . asm-mode) (\.css\' . css-mode) (\.mixal\' . mixal-mode) (\.gcov\' . compilation-mode) (/\.[a-z0-9-]*gdbinit . gdb-script-mode) (-gdb\.gdb . gdb-script-mode) ([cC]hange\.?[lL]og?\' . change-log-mode) ([cC]hange[lL]og[-.][0-9]+\' . change-log-mode) (\$CHANGE_LOG\$\.TXT . change-log-mode) (\.scm\.[0-9]*\' . scheme-mode) (\.[ckz]?sh\'\|\.shar\'\|/\.z?profile\' . sh-mode) (\.bash\' . sh-mode) (/PKGBUILD\' . sh-mode) (\(/\|\`\)\.\(bash_\(profile\|history\|log\(in\|out\)\)\|z?log\(in\|out\)\)\' . sh-mode) (\(/\|\`\)\.\(shrc\|zshrc\|m?kshrc\|bashrc\|t?cshrc\|esrc\)\' . sh-mode) (\(/\|\`\)\.\([kz]shenv\|xinitrc\|startxrc\|xsession\)\' . sh-mode) (\.m?spec\' . sh-mode) (\.m[mes]\' . nroff-mode) (\.man\' . nroff-mode) (\.sty\' . latex-mode) (\.cl[so]\' . latex-mode) (\.bbl\' . latex-mode) (\.bib\' . bibtex-mode) (\.bst\' . bibtex-style-mode) (\.sql\' . sql-mode) (\(acinclude\|aclocal\|acsite\)\.m4\' . autoconf-mode) (\.m[4c]\' . m4-mode) (\.mf\' . metafont-mode) (\.mp\' . metapost-mode) (\.vhdl?\' . vhdl-mode) (\.article\' . text-mode) (\.letter\' . text-mode) (\.i?tcl\' . tcl-mode) (\.exp\' . tcl-mode) (\.itk\' . tcl-mode) (\.icn\' . icon-mode) (\.sim\' . simula-mode) (\.mss\' . scribe-mode) (\.f9[05]\' . f90-mode) (\.f0[38]\' . f90-mode) (\.indent\.pro\' . fundamental-mode) (\.\(pro\|PRO\)\' . idlwave-mode) (\.srt\' . srecode-template-mode) (\.prolog\' . prolog-mode) (\.tar\' . tar-mode) (\.\(arc\|zip\|lzh\|lha\|zoo\|[jew]ar\|xpi\|rar\|cbr\|7z\|squashfs\|ARC\|ZIP\|LZH\|LHA\|ZOO\|[JEW]AR\|XPI\|RAR\|CBR\|7Z\|SQUASHFS\)\' . archive-mode) (\.oxt\' . archive-mode) (\.\(deb\|[oi]pk\)\' . archive-mode) (\`/tmp/Re . text-mode) (/Message[0-9]*\' . text-mode) (\`/tmp/fol/ . text-mode) (\.oak\' . scheme-mode) (\.sgml?\' . sgml-mode) (\.x[ms]l\' . xml-mode) (\.dbk\' . xml-mode) (\.dtd\' . sgml-mode) (\.ds\(ss\)?l\' . dsssl-mode) (\.js[mx]?\' . javascript-mode) (\.har\' . javascript-mode) (\.json\' . js-json-mode) (\.[ds]?va?h?\' . verilog-mode) (\.by\' . bovine-grammar-mode) (\.wy\' . wisent-grammar-mode) (\.erts\' . erts-mode) ([:/\]\..*\(emacs\|gnus\|viper\)\' . emacs-lisp-mode) (\`\..*emacs\' . emacs-lisp-mode) ([:/]_emacs\' . emacs-lisp-mode) (/crontab\.X*[0-9]+\' . shell-script-mode) (\.ml\' . lisp-mode) (\.ld[si]?\' . ld-script-mode) (ld\.?script\' . ld-script-mode) (\.xs\' . c-mode) (\.x[abdsru]?[cnw]?\' . ld-script-mode) (\.zone\' . dns-mode) (\.soa\' . dns-mode) (\.asd\' . lisp-mode) (\.\(asn\|mib\|smi\)\' . snmp-mode) (\.\(as\|mi\|sm\)2\' . snmpv2-mode) (\.\(diffs?\|patch\|rej\)\' . diff-mode) (\.\(dif\|pat\)\' . diff-mode) (\.[eE]?[pP][sS]\' . ps-mode) (\.\(?:PDF\|EPUB\|CBZ\|FB2\|O?XPS\|DVI\|OD[FGPST]\|DOCX\|XLSX?\|PPTX?\|pdf\|epub\|cbz\|fb2\|o?xps\|djvu\|dvi\|od[fgpst]\|docx\|xlsx?\|pptx?\)\' . doc-view-mode-maybe) (configure\.\(ac\|in\)\' . autoconf-mode) (\.s\(v\|iv\|ieve\)\' . sieve-mode) (BROWSE\' . ebrowse-tree-mode) (\.ebrowse\' . ebrowse-tree-mode) (#\*mail\* . mail-mode) (\.g\' . antlr-mode) (\.mod\' . m2-mode) (\.ses\' . ses-mode) (\.docbook\' . sgml-mode) (\.com\' . dcl-mode) (/config\.\(?:bat\|log\)\' . fundamental-mode) (/\.\(authinfo\|netrc\)\' . authinfo-mode) (\.\(?:[iI][nN][iI]\|[lL][sS][tT]\|[rR][eE][gG]\|[sS][yY][sS]\)\' . conf-mode) (\.la\' . conf-unix-mode) (\.ppd\' . conf-ppd-mode) (java.+\.conf\' . conf-javaprop-mode) (\.properties\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-javaprop-mode) (\.toml\' . conf-toml-mode) (\.desktop\' . conf-desktop-mode) (/\.redshift\.conf\' . conf-windows-mode) (\`/etc/\(?:DIR_COLORS\|ethers\|.?fstab\|.*hosts\|lesskey\|login\.?de\(?:fs\|vperm\)\|magic\|mtab\|pam\.d/.*\|permissions\(?:\.d/.+\)?\|protocols\|rpc\|services\)\' . conf-space-mode) (\`/etc/\(?:acpid?/.+\|aliases\(?:\.d/.+\)?\|default/.+\|group-?\|hosts\..+\|inittab\|ksysguarddrc\|opera6rc\|passwd-?\|shadow-?\|sysconfig/.+\)\' . conf-mode) ([cC]hange[lL]og[-.][-0-9a-z]+\' . change-log-mode) (/\.?\(?:gitconfig\|gnokiirc\|hgrc\|kde.*rc\|mime\.types\|wgetrc\)\' . conf-mode) (/\.mailmap\' . conf-unix-mode) (/\.\(?:asound\|enigma\|fetchmail\|gltron\|gtk\|hxplayer\|mairix\|mbsync\|msmtp\|net\|neverball\|nvidia-settings-\|offlineimap\|qt/.+\|realplayer\|reportbug\|rtorrent\.\|screen\|scummvm\|sversion\|sylpheed/.+\|xmp\)rc\' . conf-mode) (/\.\(?:gdbtkinit\|grip\|mpdconf\|notmuch-config\|orbital/.+txt\|rhosts\|tuxracer/options\)\' . conf-mode) (/\.?X\(?:default\|resource\|re\)s\> . conf-xdefaults-mode) (/X11.+app-defaults/\|\.ad\' . conf-xdefaults-mode) (/X11.+locale/.+/Compose\' . conf-colon-mode) (/X11.+locale/compose\.dir\' . conf-javaprop-mode) (\.~?[0-9]+\.[0-9][-.0-9]*~?\' nil t) (\.\(?:orig\|in\|[bB][aA][kK]\)\' nil t) ([/.]c\(?:on\)?f\(?:i?g\)?\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-mode-maybe) (\.[1-9]\' . nroff-mode) (\.art\' . image-mode) (\.avs\' . image-mode) (\.bmp\' . image-mode) (\.cmyk\' . image-mode) (\.cmyka\' . image-mode) (\.crw\' . image-mode) (\.dcr\' . image-mode) (\.dcx\' . image-mode) (\.dng\' . image-mode) (\.dpx\' . image-mode) (\.fax\' . image-mode) (\.heic\' . image-mode) (\.hrz\' . image-mode) (\.icb\' . image-mode) (\.icc\' . image-mode) (\.icm\' . image-mode) (\.ico\' . image-mode) (\.icon\' . image-mode) (\.jbg\' . image-mode) (\.jbig\' . image-mode) (\.jng\' . image-mode) (\.jnx\' . image-mode) (\.miff\' . image-mode) (\.mng\' . image-mode) (\.mvg\' . image-mode) (\.otb\' . image-mode) (\.p7\' . image-mode) (\.pcx\' . image-mode) (\.pdb\' . image-mode) (\.pfa\' . image-mode) (\.pfb\' . image-mode) (\.picon\' . image-mode) (\.pict\' . image-mode) (\.rgb\' . image-mode) (\.rgba\' . image-mode) (\.tga\' . image-mode) (\.wbmp\' . image-mode) (\.webp\' . image-mode) (\.wmf\' . image-mode) (\.wpg\' . image-mode) (\.xcf\' . image-mode) (\.xmp\' . image-mode) (\.xwd\' . image-mode) (\.yuv\' . image-mode) (\.tgz\' . tar-mode) (\.tbz2?\' . tar-mode) (\.txz\' . tar-mode) (\.tzst\' . tar-mode))

** Auto Fill
   #+BEGIN_SRC emacs-lisp :tangle "init.el"
     (add-hook 'org-mode-hook 'turn-on-auto-fill)
     (add-hook 'c-mode-hook 'turn-on-auto-fill)
     (add-hook 'TeX-mode-hook 'turn-on-auto-fill)
   #+END_SRC

  /data/github/emacs-org/ #+RESULTS:
   | turn-on-auto-fill |

But, also allow unfilling

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  ;;; It is the opposite of fill-paragraph    
  (defun unfill-paragraph ()
    "Takes a multi-line paragraph and makes it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

   ;; Handy key definition
   (define-key global-map "\M-Q" 'unfill-paragraph)
#+END_SRC

#+RESULTS:
: unfill-paragraph

* Version Control
** Git

Magit seems to be the one and only package when dealing with git
repositories. We will see, if there is something else needed ever.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
(use-package magit
  :ensure t
  :init
  (setq magit-auto-revert-mode nil)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

#+RESULTS:

** Symbolic Links

The default behavior of emacs is to ask whether to follow symbolic
links or not. If not following the link, the `file` is opened, but
there can't be interaction with the version control (magit) and thus I
like the default behavior to be follow the links.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq vc-follow-symlinks t)
#+END_SRC

** Projectile

As switching between projects becomes more and more cumbersome, I
decided to finally head over to projectile and give it a try.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package projectile
    :ensure t
    :bind (
           ("C-c p P" . projectile-switch-project)
           ("C-c p r" . projectile-ripgrep)
           ("C-c p b" . projectile-switch-to-buffer)
           ("C-c p f" . projectile-find-file)
           )

    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t
          projectile-switch-project-action 'projectile-dired
          )

    )

#+END_SRC

#+RESULTS:
: projectile-find-file

* Latex

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

#+RESULTS:
| pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f | pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f |

* Communication
** IRC
*** ERC

Typical settings for work stuff.

#+begin_src emacs-lisp
    (use-package erc
      :init
      (setq erc-server-alist
       '(("Emlix GmbH IRC Server" emlix "irc.emlix.com" 6667)
       ))
      (setq erc-autojoin-timing 'ident)
      (setq erc-nick "martin_daheeme")
      (setq erc-user-full-name "Martin H")
      (setq erc-track-shorten-start 8)
      (setq erc-autojoin-channels-alist
       '(("irc.emlix.com" "#emlix")
         ))
      (setq erc-kill-buffer-on-part t)
      (setq erc-auto-query 'bury)
      :config
      (add-hook 'erc-mode-hook
                (lambda ()
                  (setq show-trailing-whitespace nil)))
      (add-hook 'erc-list-mode-hook
                (lambda ()
                  (setq show-trailing-whitespace nil)))
      (add-to-list 'erc-modules 'notifications)
      (add-to-list 'erc-modules 'spelling)
      (add-to-list 'erc-modules 'log)
      (erc-services-mode 1)
      (erc-update-modules))
#+end_src

#+RESULTS:
: t

Message display optimizations. Align the column 20 characters to the
right such that all texts are not left aligned and start wherever the
name ends.

#+begin_src emacs-lisp
  (setq erc-fill-column 120
        erc-fill-function 'erc-fill-static
        erc-fill-static-center 20)
#+end_src

Change the prompt as having timestamps to the right is rather
annoying.

#+begin_src emacs-lisp
  (setq erc-prompt (lambda () (concat "to " (buffer-name) " >")))
  (setq erc-fill-prefix "       | ")
  (setq erc-timestamp-format "[%H:%M] | ")
#+end_src

I miss the colors in IRC so lets use a package for that.

#+begin_src emacs-lisp
  (use-package erc-hl-nicks
    :ensure t
    :after erc)
#+end_src

#+RESULTS:

Showing images appears to be nice as well

#+begin_src emacs-lisp
  (use-package erc-image
    :ensure t
    :after erc)
#+end_src

After the notifications work fine, I'd like to get notifications for
specific channels, in this case especially for all channels related to
my work IRC. [[https://jcubic.wordpress.com/2012/07/24/erc-notifications-on-channels-where-there-was-activity-after-some-inactivity/][Jakub Jankiewicz]] has a nice solution that I borrowed.

#+begin_src emacs-lisp
  (setq inactivity-buffer-alist '(("#emlix" (inactivity . 900))
                                  ("#mhtest" (inactivity . 3))))
  
  (defun async-exec-command (command &rest success)
    (interactive)
    (let* ((buffer-name (generate-new-buffer-name "**shell**"))
           (buffer (get-buffer-create buffer-name))
           (process (apply #'start-process
                           (append (list buffer-name buffer)
                                   (split-string command " ")))))
      (lexical-let ((buffer buffer) (success (car success)) (command command))
        (set-process-sentinel process
                              (if success (lambda (process str)
                                            (if (string= str "finished\n")
                                                (save-excursion
                                                  (set-buffer buffer)
                                                  (let ((content (buffer-string)))
                                                    (kill-buffer buffer)
                                                    (funcall success content)))))
                                (lambda (proces str)
                                  (kill-buffer buffer)))))
      (concat "execute: " command)))
  
  (defun channel-activity (string &rest ignore)
    "Notification when there is activity on a erc channel after inactivity"
    (let* ((buffer (buffer-name))
           (buffer-alist-pair (assoc buffer inactivity-buffer-alist))
           (buffer-alist (cdr buffer-alist-pair))
           (current-time (current-time)))
      (if (not (null buffer-alist))
          (let ((last-time-pair (assoc 'last-time buffer-alist))
                (inactivity (cdr (assoc 'inactivity buffer-alist))))
            (if (not (and (string-match "^\\*\\*\\*" string)
                          (string-match "[freenode-info]" string)))
                (progn
                  (if (or (null last-time-pair)
                          (> (float-time (time-subtract current-time
                                                        (cdr last-time-pair)))
                             inactivity))
                      (async-exec-command "mpg123 -q /home/martin/sounds/beep.mp3"))
                  (if (null last-time-pair)
                      (setf (cdr buffer-alist-pair)
                            (append buffer-alist
                                    (list (cons 'last-time current-time))))
                    (setf (cdr last-time-pair) current-time))))))))

  (add-hook 'erc-insert-pre-hook 'channel-activity)
#+end_src

#+RESULTS:
| channel-activity |

** Mail

At work I am using mutt for handling my emails, mostly because the
accessibility to all the other buffers I have opened and in part also
because I am using a en_US keyboard layout which can be kind of
problematic in official german emails. I used mutt for quite some time
now and I just found out, that I don't use the appropriate mode for my
emails. Let's fix that.

[[https://www.emacswiki.org/emacs/MuttInEmacs][Emacs Wiki]]

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-to-list 'auto-mode-alist '(".*mutt.*" . message-mode))
  (setq mail-header-separator "")
  (add-hook 'message-mode-hook
	    'turn-on-auto-fill
	    (function
	     (lambda ()
	       (progn
		 (local-unset-key "\C-c\C-c")
		 (define-key message-mode-map "\C-c\C-c" '(lambda ()
							    "save and exit quickly"
							    (interactive)
							    (save-buffer)))))))
#+END_SRC

#+RESULTS:
| turn-on-auto-fill |

Aaaand, it would be gread to use org tables in mails as well.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
#+END_SRC

*** notmuch and such

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (when (executable-find "notmuch")
    (define-key global-map "\C-cm" 'notmuch)
    (setq sendmail-program "/usr/bin/msmtp"
          notmuch-search-oldest-first nil
          mail-specify-envelope-from t
          message-sendmail-envelope-from 'header
          mail-specify-envelope-from 'header
          notmuch-show-all-multipart/alternative-parts nil
          notmuch-fcc-dirs "emlix/Sent +sent -unread"
          ))
#+END_SRC

#+RESULTS:
: emlix/Sent +sent -new

Initial cursor position in hello window

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-hook 'notmuch-hello-refresh-hook
		(lambda ()
                  (if (and (eq (point) (point-min))
                           (search-forward "Saved searches:" nil t))
                      (progn
			(forward-line)
			(widget-forward 1))
                    (if (eq (widget-type (widget-at)) 'editable-field)
			(beginning-of-line)))))

   (setq notmuch-crypto-process-mime t)
#+END_SRC

Faces

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq notmuch-search-line-faces '(("unread" :weight bold)
                                    ("flagged" :foreground "red")))
#+END_SRC

Modeline

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq martin/notmuch-activity-string "")
  (add-to-list 'global-mode-string '((:eval martin/notmuch-activity-string)) t)
  (defun martin/get-notmuch-incoming-count ()
    (string-trim
     (shell-command-to-string
      "notmuch count tag:inbox AND tag:unread AND '\(folder:INBOX or folder:INBOX.Eyeo\)'")))
  (defun martin/format-notmuch-mode-string (count)
    (concat " mails[" (if (string= count "0") "" count) "]"))
  (defun martin/update-notmuch-activity-string (&rest args)
    (setq martin/notmuch-activity-string
          (martin/format-notmuch-mode-string (martin/get-notmuch-incoming-count)))
    (force-mode-line-update))
  (add-hook 'notmuch-after-tag-hook 'martin/update-notmuch-activity-string)
  (defcustom notmuch-presync-hook nil
    "Hook run before notmuch is synchronised"
    :type 'hook)
  (defcustom notmuch-postsync-hook '(martin/update-notmuch-activity-string)
    "Hook run after notmuch has been synchronised"
    :type 'hook)

#+END_SRC

#+RESULTS:
: martin/update-notmuch-activity-string

* Learning


* Startup

Testing some scripts for startup

#+BEGIN_SRC sh
  #!/bin/bash

  #set -x

  CG=$HOME/git/CG_bitbucket
  GH=$HOME/github

  err () {
      notify-send "$1"
      exit 1
  }

  REPOSITORIES="\
                   $CG/eudyptula \
                   $CG/org \
                   $CG/misc \
                   $CG/opencv-testbed \
                   $GH/emacs-org \
                   $GH/algorithms \
                   $GH/psp \
                   $GH/psp4android \
                   $GH/thelinuxprogramminginterface \
  "

  for repo in $REPOSITORIES; do
      if [ ! -d $repo ]; then
	  err "repo $(basename $repo) is not available"
      fi

      # execute everything in a subshell, may be useful later on
      (
	  cd $repo

	  status=$(git status -s)
	  if [ "y$status" != "y" ]; then
	      # can be unstaged or untracked
	      if [ $(expr match "$status" '^??.*') -eq 0 ]; then  # if unstaged
		  err "$(basename $repo) has unstaged changes"
	      fi
	  fi

	  git status | grep -e behind >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pulling changeds from $repo"
	      {
		  git pull
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to pull repo $repo"
	      fi
	  fi

	  git status | grep -e ahead >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pushing changes to $repo"
	      {
		  git push
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to push repo $repo"
	      fi
	  fi
      )
  done
#+END_SRC

#+RESULTS:

* Ledger

I use ledger to collect any accounting data.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t)

  (setenv "PATH" (concat (concat "/home/" user-login-name "/bin:")
			 (getenv "PATH")))
  (push (concat "/home/" user-login-name "/bin") exec-path)
#+END_SRC

(getenv "PATH")
#+RESULTS:

* Org

** Org-Mode
*** General

As the most awesome people do, I too use org-mode! :)

Thanks to Isa Mert Gurbuz (https://isamert.net/)

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (use-package org
    :ensure t
    :init
    (setq org-log-done 'time)
    (setq org-clock-report-include-clocking-task t)
    :config
    (add-hook 'org-clock-in-hook 'martin/org-clock-in-set-state-to-started)
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (setq org-hide-emphasis-markers t
          org-src-window-setup 'current-window
          org-support-shift-select t
          org-use-speed-commands t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)
       (shell . t)
       (js . t)
       (python . t)
       (C . t)
       (css . t)
       (dot . t)
       (plantuml . t)
       (emacs-lisp . t)))
    )

  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)

  (use-package org-bullets
    :ensure t
    :hook (org-mode . org-bullets-mode)
    :config
    (setq org-ellipsis "➔"))

  (use-package org-fancy-priorities
    :diminish
    :ensure t
    :hook (org-mode . org-fancy-priorities-mode)
    :config (setq org-fancy-priorities-list '("🅰" "🅱" "🅲" "🅳" "🅴")))

  ;; Also here is `isamert/prettify-mode' macro.
  ;; You don't need this but it's a bit more convinient if you make use of
  ;; prettify-symbols minor mode a lot
  (defmacro isamert/prettify-mode (mode pairs)
    "Prettify given PAIRS in given MODE. Just a simple wrapper around `prettify-symbols-mode`"
    `(add-hook ,mode (lambda ()
                       (mapc (lambda (pair)
                               (push pair prettify-symbols-alist))
                             ,pairs)
                       (prettify-symbols-mode))))

  (isamert/prettify-mode 'org-mode-hook
                         '(("[ ]" . "☐")
                           ("[X]" . "☑" )
                           ("[-]" . "❍" )))
  #+END_SRC

#+RESULTS:
: t

Using actual circular bullets for bullet lists

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

#+RESULTS:

*** Taking Notes

Setting the directories for the notes to be placed in - this will be
synced soonish.

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-directory (expand-file-name "~/git/org-files"))
  (setq org-default-notes-file (expand-file-name "~/git/org-files/personal.org"))
#+END_SRC

#+RESULTS:
: ~/git/org/personal.org

**** Templates

Let's use =org-capture= to quickly add the things that come to mind all the time :)

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (defvar martin/org-project-template "* %^{Project Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00|8:00}
  :END:
  SCHEDULED: %^t
  - Why?
    %?
  - What?
  - Who?
  - Where?
  - How?
  - Outcome?
  ,** Brainstorming
    Collect 10 Ideas
  " "Full Project Description")
  (defvar martin/org-basic-task-template "* TODO %^{Task}
  SCHEDULED: %^t
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00}
  :END:
  %?
  " "Basic task data")
  (defvar martin/org-programming-workout-template "* %^{Workout Description}
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25}
  :END:
  %^g%?
  " "Programming Workout Template")
  (defvar martin/org-journal-template
    "**** %^{Description} %^g
       %?"
    "Journal Template")
  (defvar martin/org-work-journal-template
    "**** %^{Description} %^g
       %T
       %?"
    "Work Journal Template")
  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/git/org-files/personal.org" "INBOX")
           ,martin/org-basic-task-template)
          ("T" "Quick Task" entry
           (file+headline "~/git/org-files/personal.org" "INBOX")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("j" "Journal entry" plain
           (file+olp+datetree "~/git/org-files/journal.org")
           ,martin/org-journal-template)
          ("a" "Appointments" entry
           (file+headline "~/git/org-files/organizer.org" "Appointments")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline "~/git/org-files/personal.org" "Decisions")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline "~/git/org-files/personal.org" "Decisions")
           "* %?\n%i")
          ("e" "Emlix journal entry" plain
           (file+olp+datetree "~/git/org-files/emlix-journal.org")
           ,martin/org-work-journal-template)
          ("p" "Project" entry
           (file+headline "~/git/org-files/personal.org" "Projects")
           ,martin/org-project-template)
          ("w" "Work journal entry" plain
           (file+olp+datetree "~/git/org-files/work-journal.org")
           ,martin/org-work-journal-template)
          ("W" "Workout" entry
           (file+headline "~/git/org-files/personal.org" "Primary Skills")
           ,martin/org-programming-workout-template)))
  (bind-key "C-M-r" 'org-capture)
#+END_SRC

#+RESULTS:
: org-capture

**** Refiling

=org-refile= lets you organize notes by typing in the headline to file
them under.

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-entry nil)
#+END_SRC

#+RESULTS:


*** Managing Tasks

**** Track TODO state

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"   ; next action
           "TOBLOG(b)"  ; next action
           "REVIEW(r)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("REVIEW" . (:foreground "blue" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foregound "gray" :weight bold))))
#+END_SRC

#+RESULTS:
| TODO    | :foreground | green | :weight | bold |
| DONE    | :foreground | cyan  | :weight | bold |
| REVIEW  | :foreground | blue  | :weight | bold |
| WAITING | :foreground | red   | :weight | bold |
| SOMEDAY | :foregound  | gray  | :weight | bold |

**** Tag Tasks with GTD-ish contexts

This defines the key commands for those, too.

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-tag-alist '(("call" . ?c)
                        ("@computer" . ?l)
                        ("@home" . ?h)
                        ("errand" . ?e)
                        ("@office" . ?o)
                        ("@anywhere" . ?a)
                        ("meetings" . ?m)
                        ("readreview" . ?r)
                        ("writing" . ?w)
                        ("programming" . ?p)
                        ("short" . ?s)
                        ("quantified" . ?q)
                        ("highenergy" . ?1)
                        ("lowenergy" . ?0)
                        ("business" . ?B)))
#+END_SRC

#+RESULTS:

*** Org Agenda

**** Basic Configuration

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq my-org-agenda-files-list (append
                                  (file-expand-wildcards "~/git/org-files/*.org"))
        org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      my-org-agenda-files-list)))
#+END_SRC

This is some configuration of Sacha's
#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-agenda-span 'week)
  (setq org-agenda-sticky nil)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+END_SRC

#+RESULTS:
: %50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS

*** Literate Programming

For syntax highlighting of org src blocks and disabling the
confirmation of executing those blocks the following variables are set

#+BEGIN_SRC emacs-lisp :tangle "mh-modules/mh-org.el"
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
#+END_SRC

#+RESULTS:
: t

** Org-GTD

#+begin_src emacs-lisp :tangle "mh-modules/mh-org.el"
  (use-package org-gtd
    :after org
    :ensure t
    :init
    (setq org-edna-use-inheritance t
          org-gtd-directory (file-truename "~/Nextcloud/private/org/gtd")
          org-gtd-clarify-show-horizons 'right
          org-gtd-areas-of-focus '("Home" "Health" "Family" "Career" "Beer")
          )
    (org-edna-mode 1)
    :bind (("C-c d c" . org-gtd-capture)
           ("C-c d e" . org-gtd-engage)
           ("C-c d f" . org-gtd-area-of-focus-set-on-item-at-point)
           ("C-c d l" . org-gtd-clarify-item)
           :map org-gtd-clarify-map
           ("C-c c" . org-gtd-organize)
           ("C-c f" . org-gtd-area-of-focus-set-on-item-at-point)
           ("C-c t" . org-gtd-clarify-toggle-horizons-window))
  )
#+end_src

#+RESULTS:
: org-gtd-clarify-toggle-horizons-window

** Org-Roam

#+begin_src emacs-lisp :tangle "mh-modules/mh-org.el"
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory "~/Nextcloud/Martin/RoamNotes")
    :bind (("C-c n l" . org-roam-buffer-toggle)
           ("C-c n f" . org-roam-node-find)
           ("C-c n i" . org-roam-node-insert))
    :config
    (org-roam-setup))
#+end_src

#+RESULTS:

** Provide =mh-org.el= module

#+begin_src emacs-lisp :tangle "mh-modules/mh-org.el"
  (provide 'mh-org)
#+end_src

* Programming
** General

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package auto-complete
    :ensure t
    :config
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

#+RESULTS:
: t

** Language Server

To enable language server support, apparently lsp-mode is the new
standard for emacs integration. As I am mostly developing C/C++ stuff
for now, I use ccls as the language server of choice.

Find the ccls executable first
#+NAME: find-ccls
#+begin_src sh :results output :tangle no
  command -v ccls
#+end_src

#+RESULTS: find-ccls
: /usr/bin/ccls

#+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (setq lsp-use-plists t)
  (use-package ccls
    :ensure t
    :init
    (setq lsp-lens-enable nil)
    :config
    (setq ccls-executable "/usr/bin/ccls"
          gc-cons-threshold (* 1024 1024 100)
          read-process-output-max (* 1024 1024) ;; 1mb
          lsp-enable-on-type-formatting nil)
    :hook ((c-mode c++-mode) .
           (lambda () (require 'ccls) (lsp)))
    )
  (use-package lsp-mode
    :ensure t
    :commands lsp
    )
  (use-package lsp-ui
    :ensure t
    :commands lsp-ui-mode
    )
#+END_SRC

#+RESULTS:

** C

Linux kernel coding style adjustments

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun c-lineup-arglist-tabs-only ()
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (defun my/general-c-mode-configuration ()
    (setq indent-tabs-mode t)
    (setq c-basic-offset 8
          cdefault-style "linux"
          tab-width 8
          indent-tabs-mode nil
          c-set-style "linux-tabs-only")
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))
  (defun my/add-semantic-to-autocomplete ()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (defun my/general-c++-mode-configuration ()
    (setq c-basic-offset 4
          tab-width 4
          indent-tabs-mode nil)
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))

  (add-hook 'c-mode-common-hook 'my/add-semantic-to-autocomplete)
  (add-hook 'c-mode-common-hook 'my/general-c-mode-configuration)
  (add-hook 'c++-mode-hook 'my/general-c++-mode-configuration)
  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))
#+END_SRC

Define a function that intializes auto-complete-c-headers and gets
called for c/c++ hooks

#+BEGIN_SRC emacs-lisp :tangle "init.el"
    (use-package auto-complete-c-headers
      :ensure t
      :config
      (add-to-list 'ac-sources 'ac-source-c-headers))

    (defun my/init-ac-c-headers ()
      (add-to-list 'achead:include-directories '"/usr/src/linux/include/"))

    (add-hook 'c++-mode-hook 'my/init-ac-c-headers)
    (add-hook 'c-mode-hook 'my/init-ac-c-headers)
#+END_SRC

Use flycheck for syntax checking

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package flycheck
    :ensure flycheck-cstyle
    :config
    (eval-after-load 'flycheck
      '(progn
         (flycheck-cstyle-setup)
         (flycheck-add-next-checker 'c/c++-cppcheck '(warning . cstyle))))
    (global-flycheck-mode)
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-include-path
                               (list "/usr/src/linux/include" ))))
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-language-standard "c11")))
    (add-hook 'cc-mode-hook
              (lambda () (setq flycheck-gcc-language-standard "c++17")))
    (add-hook 'sh-mode-hook 'flycheck-mode)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

#+RESULTS:
: t

Highlight TODO/FIXME/etc

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun my-highlight-keywords-warning()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(FIXME\\|TODO\\|XXX+\\|BUG\\|TBD\\):"
			       1 font-lock-warning-face prepend))))
  (defun my-highlight-keywords-info()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(NOTE\\|INFO\\):"
			       1 font-lock-comment-face prepend))))

  (add-hook 'c-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c-mode-hook 'my-highlight-keywords-info)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-info)
#+END_SRC

#+RESULTS:
| my-highlight-keywords-info | my-highlight-keywords-warning | fix-enum-class | my-highlight-keywords | my/init-ac-c-headers |

Add compile keybinding and adjust initial command

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-hook 'c-mode-common-hook
            (lambda () (define-key c-mode-base-map (kbd "C-c C-l") 'compile)))



#+END_SRC

** Shell

Finally fixing the indentation of my shell mode.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun martin-setup-sh-mode()
    "sh-mode customizations."
    (interactive)
    (setq sh-basic-offset 8
          sh-indentation 8))

  (add-hook 'sh-mode-hook 'martin-setup-sh-mode)
#+END_SRC

Use shellcheck

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC

** C++

*** Indentation enum class

This indentation is not working in the original c++-mode, thus a fix is needed:

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (defun inside-class-enum-p (pos)
    "Checks if POS is within the braces of a C++ \"enum class\"."
    (ignore-errors
      (save-excursion
	(goto-char pos)
	(up-list -1)
	(backward-sexp 1)
	(looking-back "enum[ \t]+class[ \t]+[^}]+"))))

  (defun align-enum-class (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	(c-lineup-topmost-intro-cont langelem)))

  (defun align-enum-class-closing-brace (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	'-
      '+))

  (defun fix-enum-class ()
    "Setup `c++-mode' to better handle \"class enum\"."
    (add-to-list 'c-offsets-alist '(topmost-intro-cont . align-enum-class))
    (add-to-list 'c-offsets-alist
		 '(statement-cont . align-enum-class-closing-brace)))

  (add-hook 'c++-mode-hook 'fix-enum-class)
#+END_SRC

#+RESULTS:
| fix-enum-class | my/init-ac-c-headers |

** Linux
*** dts mode

After some time digging through device tree files it is time to use an
appropriate mode..

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package dts-mode
    :ensure t)
#+END_SRC

#+RESULTS:


** WebDev

For work I need some php/javascript combination support. Web-mode
gives me what I need so far.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package web-mode
    :ensure t
    :config
    (defun my-setup-php ()
      ;; enable web mode
      (web-mode)

      ;; make these variables local
      (make-local-variable 'web-mode-code-indent-offset)
      (make-local-variable 'web-mode-markup-indent-offset)
      (make-local-variable 'web-mode-css-indent-offset)

      ;; set indentation, can set different indentation level for different code type
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-markup-indent-offset 2))
    (add-to-list 'auto-mode-alist '("\\.php$" . my-setup-php))
    )
#+END_SRC

#+RESULTS:
: t

I started coding Javascript lately and thus an appropriate mode is
needed. [[http://truongtx.me][Truong TX]] gave a nice example.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))

  (use-package js2-mode
    :ensure t
    :init
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (setq js2-highlight-level 3))

  (use-package ac-js2
    :ensure t
    :init
    (add-hook 'js2-mode-hook 'ac-js2-mode))


  (use-package flymake-jslint
    :ensure t
    :config
    (add-to-list 'load-path (file-truename "~/git/lintnode"))
    (setq lintnode-location (file-truename "~/git/lintnode"))
    (setq lintnode-jslint-excludes (list 'nomen 'undef 'plusplus 'onevar 'white))
    ;;; TODO: does not work currently, investigate
                                          ; (add-hook 'js-mode-hook
                                          ;	    (lambda()
                                          ; (lintnode-hook))))
)
#+END_SRC

#+RESULTS:
: t

** Common Lisp

I learned to love slime really quickly.

#+BEGIN_SRC emacs-lisp :tangle "init.el"
  (use-package slime
    :ensure t)

  (setq inferior-lisp-program "/usr/bin/clisp")
#+END_SRC

* Org Settings
#+STARTUP: indent content hidestars
