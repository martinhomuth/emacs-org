#+STARTUP: indent content hidestars
* Personal Information

If for some reason any application will need personal information,
here they are ;-)

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Martin Homuth")
#+END_SRC

#+RESULTS:
: Martin Homuth

Load all the things I don't like to share with the world

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/secrets")
#+END_SRC

#+RESULTS:
: t

* Emacs Initialization

These settings are for emacs internals, nothing specific.

** Emacs Font
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist
    '(font . "DejaVu Sans Mono-11"))
#+END_SRC

#+RESULTS:

** Themes

My desktop machine(s) have a light i3 theme currently while the
notebook maintains a dark theme. That's why I chose to make a
difference here.

#+BEGIN_SRC emacs-lisp
  (when (or (string= system-name "devpool14")
            (string= system-name "melchior"))
    (load-theme 'tsdh-light t))
  (when (string= system-name "balthasar")
    (load-theme 'wombat t))

#+END_SRC

** Add Package Sources

   #+BEGIN_SRC emacs-lisp
          (setq package-archives
                '(("org" . "http://orgmode.org/elpa/")
                  ("gnu" . "http://elpa.gnu.org/packages/")
                  ("melpa" . "http://melpa.org/packages/")))

          (package-refresh-contents)
   #+END_SRC

   #+RESULTS:

** Add elisp directory and other files

Sacha uses external (wrt not package) files, which I'll enable too,
just to make sure it is there if I ever need it.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/elisp")
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose t)
  (use-package auto-compile
    :ensure t
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))
#+END_SRC

#+RESULTS:
: t

** General Configuration

#+BEGIN_SRC emacs-lisp
  (when window-system
    (tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (line-number-mode -1)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
          visible-bell t))

  (setq fill-column 85
        initial-scratch-message "")

  ; Whitespaces... A colleague of mine showed me the horror of not
  ; considering whitespaces and thus they are shown always and everywhere!
  (setq-default show-trailing-whitespace t)

  (fset 'yes-or-no-p 'y-or-n-p)
  (prefer-coding-system 'utf-8)
  (delete-selection-mode t)
#+END_SRC

#+RESULTS:
: t

A good addition is to toggle every whitespace character on demand.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :bind ("C-c T w" . whitespace-mode)
    :init
    (setq whitespace-line-column nil
          whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [9166 10])
                                        (tab-mark 9 [9654 9] [92 9])))
    :config
    (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
    :diminish whitespace-mode)
#+END_SRC

#+RESULTS:

** Tramp

It is really important, that the prompt that is going to be accessed
by tamp is `simple`. The following excerpt from my zsh.theme shows a
possibility to solve this:

#+BEGIN_SRC sh :tangle no :eval no
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
     PROMPT="%m> "
  else
     PROMPT="%(?.%(!.#.;).%F{1}%B;%b%f) "
  fi
#+END_SRC

Tramp itself can have various configurations for default settings.

#+BEGIN_SRC emacs-lisp
  (setq tramp-default-method "ssh"
        tramp-default-user "martin")
#+END_SRC

#+RESULTS:
: martin

** Helm - Interactive Completion

#+BEGIN_SRC emacs-lisp
  (use-package helm
               :ensure helm
               :diminish helm-mode
               :init
               (progn
                 (require 'helm-config)
                 (setq helm-candidate-number-limit 100)
                 (setq helm-idle-delay 0.0
                       helm-input-idle-delay 0.01
                       helm-quick-update t
                       helm-M-x-requires-pattern nil
                       helm-ff-skip-boring-files t)
                 (helm-mode))
               :bind (("C-c h" . helm-mini)
                      ("C-h a" . helm-apropos)
                      ("C-x C-f" . helm-find-files)
                      ("C-x C-b" . helm-buffers-list)
                      ("C-x b" . helm-buffers-list)
                      ("M-y" . helm-show-kill-ring)
                      ("M-x" . helm-M-x)
                      ("C-x c o" . helm-occur)
                      ("C-x c s" . helm-scoop)))
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure windmove
    :ensure ace-window
    :ensure hydra
    :init
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window ()
       "window"
       ("h" windmove-left)
       ("j" windmove-down)
       ("k" windmove-up)
       ("l" windmove-right)
       ("v" (\lambda ()
             (interactive)
             (split-window-right)
             (windmove-right))
        "vert")
       ("x" (\lambda ()
             (interactive)
             (split-window-below)
             (windmove-down))
        "horz")
       ("t" transpose-frame "'")
       ("o" delete-other-windows "one" :color blue)
       ("a" ace-window "ace")
       ("s" ace-swap-window "swap")
       ("d" ace-delete-window "del")
       ("i" ace-maximize-window "ace-one" :color blue)
       ("b" switch-to-buffer "buf")
       ("m" headlong-bookmark-jump "bmk")
       ("q" nil "cancel"))))
#+END_SRC

#+RESULTS:

** Startup File

Load my personal org file after startup.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        initial-buffer-choice (expand-file-name "~/git/org/personal.org"))
#+END_SRC

#+RESULTS:
| personal.org |

** Key Bindings
#+BEGIN_SRC emacs-lisp
  ;; General
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-unset-key (kbd "C-z"))
  (global-set-key [f1] 'eshell)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  ;; Org-Mode
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c O" 'org-open-at-point-global)
  (bind-key "<f9>" 'org-agenda-list)
  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)
#+END_SRC

#+RESULTS:
: org-agenda-clock-in

#+END_SRC

#+RESULTS:
: magit-status

* Navigation
** Better Beginning Of The Line

#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
  (global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line

** Helm-Swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :defer t
    :bind
    (("C-S-s" . helm-swoop)
     ("M-i" . helm-swoop)
     ("M-s s" . helm-swoop)
     ("C-x M-i" . helm-multi-swoop-all))
    :config
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+END_SRC

#+RESULTS:
* Version Control
** Git

Magit seems to be the one and only package when dealing with git
repositories. We will see, if there is something else needed ever.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (setq magit-auto-revert-mode nil)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

#+RESULTS:

** Symbolic Links

The default behavior of emacs is to ask whether to follow symbolic
links or not. If not following the link, the `file` is opened, but
there can't be interaction with the version control (magit) and thus I
like the default behavior to be follow the links.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

* Org-Mode
** General

As the most awesome people do, I too use org-mode! :)

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (setq org-clock-idle-time nil)
    (setq org-log-done 'time)
    (setq org-clock-persist t)
    (setq org-clock-report-include-clocking-task t)
    :config
    (org-clock-persistence-insinuate)
    (add-hook 'org-clock-in-hook 'martin/org-clock-in-set-state-to-started)
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (eval-after-load 'org-agenda
      '(bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
      (setq org-hide-emphasis-markers t)
    )
  #+END_SRC

#+RESULTS:
: t

** Publish HTML

Recently I played with writing my blog with org-mode but I did not
have the time yet to steamline it.

#+BEGIN_SRC emacs-lisp :export no
  (use-package ox-publish
    :config
    (setq org-publish-project-alist
          '(
            ("org-notes"
             :base-directory "~/web/martinhomuth_org/"
             :base-extension "org"
             :publishing-directory "~/web/martinhomuth/"
             :recursive t
             :publishing-function org-html-publish-to-html
             :headline-levels 4
             :auto-preamble
             )
            ("org-static"
             :base-directory "~/web/martinhomuth_org/"
             :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
             :publishing-directory "~/web/martinhomuth/"
             :recursive t
             :publishing-function org-publish-attachment
             )
            ("org" :components ("org-notes" "org-static"))
            )))
#+END_SRC

#+RESULTS:
: t

** Taking Notes

Setting the directories for the notes to be placed in - this will be
synced soonish.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/git/org")
  (setq org-default-notes-file "~/git/org/personal.org")
#+END_SRC

#+RESULTS:
: ~/git/org/personal.org

*** Templates

Let's use =org-capture= to quickly add the things that come to mind all the time :)

#+BEGIN_SRC emacs-lisp
  (defvar martin/org-project-template "* %^{Project Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00|8:00}
  :END:
  SCHEDULED: %^t
  Why? %?
  What?
  Who?
  Where?
  How?
  Outcome?
  ,** Brainstorming
    Collect 10 Ideas
  " "Full Project Description")
  (defvar martin/org-basic-task-template "* TODO %^{Task}
  SCHEDULED: %^t
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00}
  :END:
  %?
  " "Basic task data")
  (defvar martin/org-programming-workout-template "* %^{Workout Description}
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25}
  :END:
  %^g%?
  " "Programming Workout Template")
  (defvar martin/org-journal-template
    "**** %^{Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25|0:30|0:45|1:00|2:00|4:00|8:00}
  :END:
  %T"
    "Journal Template")
  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/git/org/personal.org" "INBOX")
           ,martin/org-basic-task-template)
          ("T" "Quick Task" entry
           (file+headline "~/git/org/personal.org" "INBOX")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("j" "Journal entry" plain
           (file+datetree "~/git/org/journal.org")
           ,martin/org-journal-template
           :immediate-finish t)
          ("a" "Appointments" entry
           (file+headline "~/git/org/organizer.org" "Appointments")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline "~/git/org/personal.org" "Decisions")
           "* %?\n%i")
          ("p" "Project" entry
           (file+headline "~/git/org/personal.org" "Projects")
           ,martin/org-project-template)
          ("W" "Workout" entry
           (file+headline "~/git/org/personal.org" "Primary Skills")
           ,martin/org-programming-workout-template)))
  (bind-key "C-M-r" 'org-capture)
#+END_SRC

#+RESULTS:
: org-capture

*** Refiling

=org-refile= lets you organize notes by typing in the headline to file
them under.

#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-entry nil)
#+END_SRC

#+RESULTS:

** org-caldav

#+BEGIN_SRC emacs-lisp
  (use-package org-caldav
    :ensure t
    :config
    (setq org-caldav-url martin-caldav-url)
    (setq org-caldav-calendars
          '((:calendar-id "personal" :files ("~/git/org/personal.org" "~/git/org/organizer.org" "~/git/org/journal.org")
                          :inbox "~/git/org/inbox/frompersonal.org")
            (:calendar-id "work"
                          :files ("~/git/org/work.org")
                          :inbox "~/git/org/inbox/fromwork.org"))))

#+END_SRC

#+RESULTS:
: t

** Managing Tasks

*** Track TODO state

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"   ; next action
           "TOBLOG(b)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foregound "gray" :weight bold))))
#+END_SRC

#+RESULTS:
| TODO    | :foreground | green | :weight | bold |
| DONE    | :foreground | cyan  | :weight | bold |
| WAITING | :foreground | red   | :weight | bold |
| SOMEDAY | :foregound  | gray  | :weight | bold |

*** Tag Tasks with GTD-ish contexts

This defines the key commands for those, too.

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("call" . ?c)
                        ("@computer" . ?l)
                        ("@home" . ?h)
                        ("errand" . ?e)
                        ("@office" . ?o)
                        ("@anywhere" . ?a)
                        ("meetings" . ?m)
                        ("readreview" . ?r)
                        ("writing" . ?w)
                        ("programming" . ?p)
                        ("short" . ?s)
                        ("quantified" . ?q)
                        ("highenergy" . ?1)
                        ("lowenergy" . ?0)
                        ("business" . ?B)))
#+END_SRC

#+RESULTS:

*** Enable Filtering by Effort Estimates

That way it is easy to see short tasks that i can finish fast

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-global-properties
               '("Effort_ALL" . "0:05 0:10 0:15 0:20 0:25 0:30 0:45 1:00 2:00 4:00"))
#+END_SRC

#+RESULTS:

*** Track Time
#+BEGIN_SRC emacs-lisp

  (defun martin/org-clock-in-set-state-to-started ()
    "Mark STARTED when clocked in."
    (save-excursion
      (catch 'exit
        (cond
         ((derived-mode-p 'org-agenda-mode)
          (let* ((marker (or (org-get-at-bol 'org-marker)
                             (org-agenda-error)))
                 (hdmarker (or (org-get-at-bol 'org-hd-marker) marker))
                 (pos (marker-position marker))
                 (col (current-column))
                 newhead)
            (org-with-remote-undo (marker-buffer marker)
              (with-current-buffer (marker-buffer marker)
                (widen)
                (goto-char pos)
                (org-back-to-heading t)
                (if (org-get-todo-state)
                    (org-todo "STARTED"))))))
         (t (if (org-get-todo-state)
                (org-todo "STARTED")))))))
#+END_SRC

#+RESULTS:
: martin/org-clock-in-set-state-to-started

Too many clock entries clutter up a heading
#+BEGIN_SRC emacs-lisp
  (setq org-log-into-drawer "LOGBOOK")
  (setq org-clock-into-drawer 1)
#+END_SRC

#+RESULTS:
: 1

*** Habits

#+BEGIN_SRC emacs-lisp
  (setq org-habit-graph-column 80)
  (setq org-habit-show-habits-only-for-today nil)
#+END_SRC

#+RESULTS:

*** Estimating Tasks

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-clock-in-prepare-hook
            'martin/org-mode-ask-effort)
  (defun martin/org-mode-ask-effort ()
    "Ask for an effort estimate when clocking in."
    (unless (org-entry-get (point) "Effort")
      (let ((effort
             (completing-read
              "Effort: "
              (org-entry-get-multivalued-property (point) "Effort"))))
        (unless (equal effort "")
          (org-set-property "Effort" effort)))))
#+END_SRC

#+RESULTS:
: martin/org-mode-ask-effort

** Org Agenda

*** Basic Configuration
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      '("~/git/org/personal.org"
                        "~/git/org/work.org"
                        "~/git/org/journal.org"
                        "~/git/org/organizer.org"))))
#+END_SRC

#+RESULTS:
| ~/git/org/personal.org | ~/git/org/work.org | ~/git/org/journal.org | ~/git/org/organizer.org |

This is some configuration of Sacha's
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 2)
  (setq org-agenda-sticky nil)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          "-------------"
          (800 1000 1200 1400 1600 1800)))
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+END_SRC

#+RESULTS:
: %50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS


* Programming
** General

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    (require 'auto-complete-config)
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

#+RESULTS:
: t

** C

Simple C-mode adjustments

#+BEGIN_SRC emacs-lisp
  (require 'cc-mode)
  (setq-default
   c-basic-offset 8
   cdefault-style "linux"
   tab-width 8
   indent-tabs-mode t)
  (define-key c-mode-base-map (kbd "RET") 'newline-and-indent)

  (defun compile-parent (command)
    (interactive
     (let* ((make-directory (locate-dominating-file (buffer-file-name)
                                                    "Makefile"))
            (command (concat "make -k -C "
                             (shell-quote-argument make-directory))))
       (list (compilation-read-command command))))
    (compile command))
#+END_SRC

#+RESULTS:
: compile-parent

C-mode hooks that just load when c-mode is activated

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook
            (lambda ()
              (unless (file-exists-p "Makefile")
                (set (make-local-variable 'compile-command)
                     (let ((file (file-name-nondirectory buffer-file-name)))
                       (format "%s %s %s %s -o %s"
                               (or (getenv "CC") "gcc")
                               (or (getenv "CPPFLAGS") "-DDEBUG=9")
                               (or (getenv "CFLAGS") "-Werror -pedantic -Wall -g -std=c11")
                               file
                               (file-name-sans-extension file))
                       (when (and filename
                                  (string-match (expand-file-name "~/src/linux-trees")
                                                filename))
                         (setq indent-tabs-mode t)
                         (setq show-trailing-whitespace t)
                         (c-set-style "linux-tabs-only")))))
              (add-to-list 'ac-sources 'ac-source-c-headers)
              (add-to-list 'ac-sources 'ac-source-c-header-symbols t)
              (hs-minor-mode)))

  (defun c-lineup-arglist-tabs-only (ignored)
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (add-hook 'c-mode-common-hook
            (lambda ()
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))

#+END_SRC

#+RESULTS:
| (lambda nil (c-add-style linux-tabs-only (quote (linux (c-offsets-alist (arglist-cont-nonempty c-lineup-gcc-asm-reg c-lineup-arglist-tabs-only)))))) | my/add-semantic-to-autocomplete |

#+BEGIN_SRC emacs-lisp
  (semantic-mode 1)
  (defun my/add-semantic-to-autocomplete ()
    (add-to-list 'ac-sources 'ac-source-semantic))
  (add-hook 'c-mode-common-hook 'my/add-semantic-to-autocomplete)
#+END_SRC

#+RESULTS:
| my/add-semantic-to-autocomplete |
