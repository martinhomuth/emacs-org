#+STARTUP: indent content hidestars
* Personal Information

If for some reason any application will need personal information,
here they are ;-)

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Martin Homuth")
#+END_SRC

#+RESULTS:
: Martin Homuth

Load all the things I don't like to share with the world

#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/secrets")
#+END_SRC

#+RESULTS:
: t

* Emacs Initialization

These settings are for emacs internals, nothing specific.

** Emacs Font
#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'default-frame-alist
  ;;              `(font . ,(concat "DejaVu Sans Mono-" (number-to-string fontsize))))
  ;; (set-fontset-font "fontset-default" nil
  ;;                   (font-spec :size 20 :name "Symbola"))
  ;; disable CJK coding/encoding
  (setq utf-translate-cjk-mode nil)
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-file-name-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)

  ;; backwards compatibility
  (if (boundp buffer-file-coding-system)
      (setq buffer-file-coding-system 'utf-8)
    (setq default-buffer-file-coding-system 'utf-8))

  ;; Treat clipboard as UTF-8 string first
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |

** Themes

My desktop machine(s) have a light i3 theme currently while the
notebook maintains a dark theme. That's why I chose to make a
difference here. This is hidden in secrets.el to avoid information
leaking about differences.

#+BEGIN_SRC emacs-lisp
  (load-theme mytheme t)
  (setq-default cursor-type 'hbar)
  (global-hl-line-mode)

#+END_SRC

#+RESULTS:
: t

Let's not use any theme on terminal instances of Emacs..

#+BEGIN_SRC emacs-lisp
  (defun on-after-init()
    (unless (display-graphic-p (selected-frame))
      (set-face-background 'default "unspecified-bg" (selected-frame))))

  (add-hook 'window-setup-hook 'on-after-init)
#+END_SRC

** Server

Starting the server at emacs start should be handy someday..

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

#+RESULTS:

** Add Package Sources

   #+BEGIN_SRC emacs-lisp
     (unless (assoc-default "melpa" package-archives)
       (add-to-list 'package-archives
      	      '("melpa" . "http://melpa.org/packages/")))

     (unless (assoc-default "org" package-archives)
       (add-to-list 'package-archives
      	      '("org" . "http://orgmode.org/elpa/")))
   #+END_SRC

   #+RESULTS:

** Add elisp directory and other files

Sacha uses external (wrt not package) files, which I'll enable too,
just to make sure it is there if I ever need it.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/elisp")
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-verbose t)
  (use-package auto-compile
    :ensure t
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))
#+END_SRC

#+RESULTS:
: t

** General Configuration

#+BEGIN_SRC emacs-lisp
  (when window-system
    (tooltip-mode -1)
    (tool-bar-mode -1)
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (line-number-mode -1)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)
          visible-bell t))

  (setq fill-column 85
        initial-scratch-message "")

  ; Whitespaces... A colleague of mine showed me the horror of not
  ; considering whitespaces and thus they are shown always and everywhere!
  (setq-default show-trailing-whitespace t)

  (fset 'yes-or-no-p 'y-or-n-p)
  (prefer-coding-system 'utf-8)
  (delete-selection-mode t)
#+END_SRC

#+RESULTS:
: t

A good addition is to toggle every whitespace character on demand.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :bind ("C-c T w" . whitespace-mode)
    :init
    (setq whitespace-line-column nil
          whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [9166 10])
                                        (tab-mark 9 [9654 9] [92 9])))
    :config
    (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
    :diminish whitespace-mode)
#+END_SRC

#+RESULTS:

** Tramp

It is really important, that the prompt that is going to be accessed
by tamp is `simple`. The following excerpt from my zsh.theme shows a
possibility to solve this:

#+BEGIN_SRC sh :tangle no :eval no
  if [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then
     PROMPT="%m> "
  else
     PROMPT="%(?.%(!.#.;).%F{1}%B;%b%f) "
  fi
#+END_SRC

Tramp itself can have various configurations for default settings.

#+BEGIN_SRC emacs-lisp :eval no
  (setq tramp-default-method "ssh"
        tramp-default-user "martin")
#+END_SRC

#+RESULTS:
: martin

** Helm - Interactive Completion

#+BEGIN_SRC emacs-lisp
  (use-package helm
               :ensure helm
               :diminish helm-mode
               :config
               (progn
                 (require 'helm-config)
                 (setq helm-candidate-number-limit 100)
                 (setq helm-idle-delay 0.0
                       helm-input-idle-delay 0.01
                       helm-quick-update t
                       helm-M-x-requires-pattern nil)
                 (helm-mode))
               :bind (("C-c h" . helm-mini)
                      ("C-h a" . helm-apropos)
                      ("C-x C-f" . helm-find-files)
                      ("C-x C-b" . helm-buffers-list)
                      ("C-x b" . helm-buffers-list)
                      ("M-y" . helm-show-kill-ring)
                      ("M-x" . helm-M-x)
                      ("C-x c o" . helm-occur)
                      ("C-x c s" . helm-scoop)))
#+END_SRC

** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure windmove
    :ensure ace-window
    :ensure hydra
    :init
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window ()
       "window"
       ("h" windmove-left)
       ("j" windmove-down)
       ("k" windmove-up)
       ("l" windmove-right)
       ("v" (\lambda ()
             (interactive)
             (split-window-right)
             (windmove-right))
        "vert")
       ("x" (\lambda ()
             (interactive)
             (split-window-below)
             (windmove-down))
        "horz")
       ("t" transpose-frame "'")
       ("o" delete-other-windows "one" :color blue)
       ("a" ace-window "ace")
       ("s" ace-swap-window "swap")
       ("d" ace-delete-window "del")
       ("i" ace-maximize-window "ace-one" :color blue)
       ("b" switch-to-buffer "buf")
       ("m" headlong-bookmark-jump "bmk")
       ("q" nil "cancel"))))
#+END_SRC

#+RESULTS:

** Startup File

Load my personal org file after startup.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        initial-buffer-choice (expand-file-name "~/git/CG_bitbucket/org/personal.org"))
#+END_SRC

#+RESULTS:
| personal.org |

** Exit Confirmation

Even though unsaved buffers saved me lots of times due to prompting
for save, it happened quite often that I closed Emacs because of
mistyping. Maybe a confirmation helps and is not really annoying -
when in window system.

#+BEGIN_SRC emacs-lisp
  (defun martin-save-buffers-kill-emacs-with-confirm ()
    "Thanks to jsled for this method"
    (interactive)
    (if (window-system)
	(if (null current-prefix-arg)
	    (if (y-or-n-p "Are you sure you want to quit?")
		(save-buffers-kill-emacs))
	  (save-buffers-kill-emacs))
      (save-buffers-kill-terminal)))
  (global-set-key "\C-x\C-c" 'martin-save-buffers-kill-emacs-with-confirm)
#+END_SRC

#+RESULTS:
: martin-save-buffers-kill-emacs-with-confirm

** Snippets

From Sacha Chuas Configuration for testing

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode ;; used to remove mode line information that is not used
    :init (yas-global-mode)
    :config
    (progn
      (yas-global-mode)
      (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
      (setq yas-key-syntaxes '("w_" "w_." "^ "))
      (setq yas-installed-snippets-dir "~/elisp/yasnippet-snippets")
      (setq yas-expand-only-for-last-commands nil)
      (yas-global-mode 1)
      (bind-key "\t" 'hippie-expand yas-minor-mode-map)))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
  (setq default-cursor-color "gray")
  (setq yasnippet-can-fire-cursor-color "purple")

  ;; It will test whether it can expand, if yes, cursor color -> green.
  (defun yasnippet-can-fire-p (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
	(setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
							(yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (and templates-and-pos (first templates-and-pos))))

  (defun my/change-cursor-color-when-can-expand (&optional field)
    (interactive)
    (when (eq last-command 'self-insert-command)
      (set-cursor-color (if (my/can-expand)
                            yasnippet-can-fire-cursor-color
                          default-cursor-color))))

  (defun my/can-expand ()
    "Return true if right after an expandable thing."
    (or (abbrev--before-point) (yasnippet-can-fire-p)))

  (remove-hook 'post-command-hook 'my/change-cursor-color-when-can-expand)

  (defun my/insert-space-or-expand ()
    "For binding to the SPC SPC keychord."
    (interactive)
    (condition-case nil (or (my/hippie-expand-maybe nil) (insert "  "))))
#+END_SRC

#+RESULTS:
: my/insert-space-or-expand

** Key Bindings
#+BEGIN_SRC emacs-lisp
  ;; General
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-unset-key (kbd "C-z"))
  (global-set-key [f1] 'eshell)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  ;; Org-Mode
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c O" 'org-open-at-point-global)
  (bind-key "<f9>" 'org-agenda-list)
  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)
#+END_SRC

#+RESULTS:
: org-agenda-clock-in

#+END_SRC

#+RESULTS:
: magit-status

* Navigation
** Better Beginning Of The Line

Thanks to Howard Abrams for this neat function!

#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
  (global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line

** Better delete line

I am used to delete my lines using C-k and with the previous changes
from Better Beginning Of The Line this can be cumbersome. Therefore
there is a need for changing this behavior to deleting the whole line
if the point is at the beginning of the line.

#+BEGIN_SRC emacs-lisp :eval no :tangle no
  (defun hungry-eat-line ()
    ""
    (interactive)
    (save-excursion
      (let ((indent-point
             (save-excursion
               (back-to-indentation)
        (if (= indent-point (point))
            (kill-whole-line)
          (kill-line nil))))))))

  (global-set-key (kbd "C-k") 'hungry-eat-line)
#+END_SRC

#+RESULTS:
: hungry-eat-line

** Helm-Swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
    :ensure t
    :defer t
    :bind
    (("C-S-s" . helm-swoop)
     ("M-i" . helm-swoop)
     ("M-s s" . helm-swoop)
     ("C-x M-i" . helm-multi-swoop-all))
    :config
    (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
    (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop))
#+END_SRC

#+RESULTS:

** Dired

Handling dired buffers is kind of cumbersome for me, especially
because opening a folder means more buffers for every folder I
enter. This is not bad per se, but not really what I would
like. Following the great emacs news by Sacha Chua, I found [[http://xenodium.com/#drill-down-emacs-dired-with-dired-subtree][this]] on
reddit:

#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (setq dired-subtree-use-backgrounds nil)
    (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))
#+END_SRC

#+RESULTS:
: t

* Input
** Default input method

I use the 'german-prefix' input method regularly and thus this should
be the default all the time. Maybe I'll tweak that someday if becomes
cumbersome.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method "german-prefix")
#+END_SRC

#+RESULTS:
: german-prefix

* Version Control
** Git

Magit seems to be the one and only package when dealing with git
repositories. We will see, if there is something else needed ever.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (setq magit-auto-revert-mode nil)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

#+RESULTS:

** Symbolic Links

The default behavior of emacs is to ask whether to follow symbolic
links or not. If not following the link, the `file` is opened, but
there can't be interaction with the version control (magit) and thus I
like the default behavior to be follow the links.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Projectile

As switching between projects becomes more and more cumbersome, I
decided to finally head over to projectile and give it a try.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :ensure helm-projectile
    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t
          projectile-switch-project-action 'projectile-dired
          )

    )

#+END_SRC

#+RESULTS:
: t

* Communication
** circe

For work, I'd like to use an emacs IRC client. If it prooves to be
good, I will switch to it generally.

#+BEGIN_SRC emacs-lisp :eval no
  (use-package circe
    :ensure t
    :config
    (setq circe-network-options
          `((,work-irc-server
           :tls nil
           :port 6667
           :nick "martin"
           :channels (,work-irc-channel)
           ))))
#+END_SRC

#+RESULTS:
: t

* Learning


* Startup

Testing some scripts for startup

#+BEGIN_SRC shell
  #!/bin/sh
  # This script handles various different startup tasks

  # synchronization of important git repositories
  REPOS="github/martinhomuth/repos/emacs-org git/dotfiles git/CG_bitbucket/org"

  echo -n "Updating repositories"
  echo "============================" >>/var/log/startup.log
  for repo in $REPOS; do
      pushd ~/$repo >/dev/null
      # if ~ breaks, use lisp variable user-login-name
      echo -n "."
      echo -e "------------------------------\n$(date) - $repo" >> /var/log/startup.log 2>&1
      {
          git pull
      } >> /var/log/startup.log 2>&1
      if [ $? -eq 1 ]; then
          notify-send "Git repository $repo" "Pull failed"
          # TODO check for needed push
      fi
      popd >/dev/null
  done
  echo "done."
  echo "============================" >>/var/log/startup.log
#+END_SRC

#+RESULTS:
: Updating repositories.done.

* Ledger

I use ledger to collect any accounting data.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t)
#+END_SRC

#+RESULTS:

* Org-Mode
** General

As the most awesome people do, I too use org-mode! :)

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (setq org-log-done 'time)
    (setq org-clock-report-include-clocking-task t)
    :config
    (add-hook 'org-clock-in-hook 'martin/org-clock-in-set-state-to-started)
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (eval-after-load 'org-agenda
      '(bind-key "i" 'org-agenda-clock-in org-agenda-mode-map))
    (setq org-hide-emphasis-markers t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)
       (shell . t)
       (js . t)
       (python . t)
       (C . t)
       (css . t)
       (dot . t)
       (plantuml . t)
       (emacs-lisp . t)))
    )

  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
    (setq
     ;org-bullets-bullet-list '("✙" "♱" "♰" "☥" "✞" "✟" "✝" "†" "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥")
          org-ellipsis "➔"))
  #+END_SRC

#+RESULTS:
: t

Using actual circular bullets for bullet lists

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

#+RESULTS:

And now some header stuff

#+BEGIN_SRC emacs-lisp
  (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                               ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                               ((x-list-fonts "Verdana")         '(:font "Verdana"))
                               ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                               (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
         (base-font-color     (face-foreground 'default nil 'default))
         (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

    (custom-theme-set-faces 'user
                            `(org-level-8 ((t (,@headline ,@variable-tuple))))
                            `(org-level-7 ((t (,@headline ,@variable-tuple))))
                            `(org-level-6 ((t (,@headline ,@variable-tuple))))
                            `(org-level-5 ((t (,@headline ,@variable-tuple))))
                            `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                            `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
                            `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
                            `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
                            `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
#+END_SRC

#+RESULTS:

** Publish HTML

Recently I played with writing my blog with org-mode but I did not
have the time yet to steamline it.

#+BEGIN_SRC emacs-lisp :export no
  (use-package ox-publish
    :config
    (setq org-publish-project-alist
          '(
            ("org-notes"
             :base-directory "~/web/martinhomuth_org/"
             :base-extension "org"
             :publishing-directory "~/web/martinhomuth/"
             :recursive t
             :publishing-function org-html-publish-to-html
             :headline-levels 4
             :auto-preamble
             )
            ("org-static"
             :base-directory "~/web/martinhomuth_org/"
             :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
             :publishing-directory "~/web/martinhomuth/"
             :recursive t
             :publishing-function org-publish-attachment
             )
            ("org" :components ("org-notes" "org-static"))
            )))
#+END_SRC

#+RESULTS:
: t

** Taking Notes

Setting the directories for the notes to be placed in - this will be
synced soonish.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/git/CG_bitbucket/org")
  (setq org-default-notes-file "~/git/CG_bitbucket/org/personal.org")
#+END_SRC

#+RESULTS:
: ~/git/org/personal.org

*** Templates

Let's use =org-capture= to quickly add the things that come to mind all the time :)

#+BEGIN_SRC emacs-lisp
  (defvar martin/org-project-template "* %^{Project Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00|8:00}
  :END:
  SCHEDULED: %^t
  Why? %?
  What?
  Who?
  Where?
  How?
  Outcome?
  ,** Brainstorming
    Collect 10 Ideas
  " "Full Project Description")
  (defvar martin/org-basic-task-template "* TODO %^{Task}
  SCHEDULED: %^t
  :PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00}
  :END:
  %?
  " "Basic task data")
  (defvar martin/org-programming-workout-template "* %^{Workout Description}
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25}
  :END:
  %^g%?
  " "Programming Workout Template")
  (defvar martin/org-journal-template
    "**** %^{Description} %^g
  :PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25|0:30|0:45|1:00|2:00|4:00|8:00}
  :END:
  %T"
    "Journal Template")
  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline "~/git/CG_bitbucket/org/personal.org" "INBOX")
           ,martin/org-basic-task-template)
          ("T" "Quick Task" entry
           (file+headline "~/git/CG_bitbucket/org/personal.org" "INBOX")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("j" "Journal entry" plain
           (file+datetree "~/git/CG_bitbucket/org/journal.org")
           ,martin/org-journal-template
           :immediate-finish t)
          ("a" "Appointments" entry
           (file+headline "~/git/CG_bitbucket/org/organizer.org" "Appointments")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline "~/git/CG_bitbucket/org/personal.org" "Decisions")
           "* %?\n%i")
          ("p" "Project" entry
           (file+headline "~/git/CG_bitbucket/org/personal.org" "Projects")
           ,martin/org-project-template)
          ("W" "Workout" entry
           (file+headline "~/git/CG_bitbucket/org/personal.org" "Primary Skills")
           ,martin/org-programming-workout-template)))
  (bind-key "C-M-r" 'org-capture)
#+END_SRC

#+RESULTS:
: org-capture

*** Refiling

=org-refile= lets you organize notes by typing in the headline to file
them under.

#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-entry nil)
#+END_SRC

#+RESULTS:

** org-caldav

#+BEGIN_SRC emacs-lisp
  (use-package org-caldav
    :ensure t
    :config
    (setq org-caldav-url martin-caldav-url)
    (setq org-caldav-calendars
          '((:calendar-id "personal"
                          :files
			  ("~/git/CG_bitbucket/org/personal.org"
			   "~/git/CG_bitbucket/org/organizer.org"
			   "~/git/CG_bitbucket/org/journal.org")
                          :inbox
			  "~/git/CG_bitbucket/org/inbox/frompersonal.org")
            (:calendar-id "work"
                          :files
			  ("~/git/CG_bitbucket/org/work.org")
                          :inbox
			  "~/git/CG_bitbucket/org/inbox/fromwork.org"))))

#+END_SRC

#+RESULTS:
: t

** Rifling

While I do organize my org files in a way I can find information
quite easily, a little help is always appreciated, let's see if
helm-org-rifle is a viable candidate :)

#+BEGIN_SRC emacs-lisp
  (use-package s
    :ensure t)

  (use-package helm-org-rifle
    :ensure t
    :init
    (require 'helm-org-rifle))
#+END_SRC

#+RESULTS:

** Managing Tasks

*** Track TODO state

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"   ; next action
           "TOBLOG(b)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foregound "gray" :weight bold))))
#+END_SRC

#+RESULTS:
| TODO    | :foreground | green | :weight | bold |
| DONE    | :foreground | cyan  | :weight | bold |
| WAITING | :foreground | red   | :weight | bold |
| SOMEDAY | :foregound  | gray  | :weight | bold |

*** Tag Tasks with GTD-ish contexts

This defines the key commands for those, too.

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("call" . ?c)
                        ("@computer" . ?l)
                        ("@home" . ?h)
                        ("errand" . ?e)
                        ("@office" . ?o)
                        ("@anywhere" . ?a)
                        ("meetings" . ?m)
                        ("readreview" . ?r)
                        ("writing" . ?w)
                        ("programming" . ?p)
                        ("short" . ?s)
                        ("quantified" . ?q)
                        ("highenergy" . ?1)
                        ("lowenergy" . ?0)
                        ("business" . ?B)))
#+END_SRC

#+RESULTS:

*** Enable Filtering by Effort Estimates

That way it is easy to see short tasks that i can finish fast

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-global-properties
               '("Effort_ALL" . "0:05 0:10 0:15 0:20 0:25 0:30 0:45 1:00 2:00 4:00"))
#+END_SRC

#+RESULTS:

*** Track Time
#+BEGIN_SRC emacs-lisp

  (defun martin/org-clock-in-set-state-to-started ()
    "Mark STARTED when clocked in."
    (save-excursion
      (catch 'exit
        (cond
         ((derived-mode-p 'org-agenda-mode)
          (let* ((marker (or (org-get-at-bol 'org-marker)
                             (org-agenda-error)))
                 (hdmarker (or (org-get-at-bol 'org-hd-marker) marker))
                 (pos (marker-position marker))
                 (col (current-column))
                 newhead)
            (org-with-remote-undo (marker-buffer marker)
              (with-current-buffer (marker-buffer marker)
                (widen)
                (goto-char pos)
                (org-back-to-heading t)
                (if (org-get-todo-state)
                    (org-todo "STARTED"))))))
         (t (if (org-get-todo-state)
                (org-todo "STARTED")))))))
#+END_SRC

#+RESULTS:
: martin/org-clock-in-set-state-to-started

Too many clock entries clutter up a heading
#+BEGIN_SRC emacs-lisp
  (setq org-log-into-drawer "LOGBOOK")
  (setq org-clock-into-drawer 1)
#+END_SRC

#+RESULTS:
: 1

*** Habits

#+BEGIN_SRC emacs-lisp
  (setq org-habit-graph-column 80)
  (setq org-habit-show-habits-only-for-today nil)
#+END_SRC

#+RESULTS:

*** Estimating Tasks

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-clock-in-prepare-hook
            'martin/org-mode-ask-effort)
  (defun martin/org-mode-ask-effort ()
    "Ask for an effort estimate when clocking in."
    (unless (org-entry-get (point) "Effort")
      (let ((effort
             (completing-read
              "Effort: "
              (org-entry-get-multivalued-property (point) "Effort"))))
        (unless (equal effort "")
          (org-set-property "Effort" effort)))))
#+END_SRC

#+RESULTS:
: martin/org-mode-ask-effort

** Org Agenda

*** Basic Configuration
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      '("~/git/CG_bitbucket/org/personal.org"
                        "~/git/CG_bitbucket/org/work.org"
                        "~/git/CG_bitbucket/org/journal.org"
                        "~/git/CG_bitbucket/org/organizer.org"))))
#+END_SRC

#+RESULTS:
| ~/git/org/personal.org | ~/git/org/work.org | ~/git/org/journal.org | ~/git/org/organizer.org |

This is some configuration of Sacha's
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 2)
  (setq org-agenda-sticky nil)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-agenda-time-grid
        '((daily today require-timed)
          "-------------"
          (800 1000 1200 1400 1600 1800)))
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+END_SRC

#+RESULTS:
: %50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS


* Programming
** General

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    (require 'auto-complete-config)
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

#+RESULTS:
: t

** C

Linux kernel coding style adjustments

#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only (ignored)
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
	 c-basic-offset)))

  (defun my:general-c-mode-configuration ()
    (setq indent-tabs-mode t)
    (setq show-trailing-whitespace t
          c-basic-offset 8
          cdefault-style "linux"
          tab-width 8)
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))

  (add-hook 'c-mode-common-hook 'my:general-c-mode-configuration)

  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))
  (add-hook 'c-mode-hook
            (lambda ()
              (let ((filename (buffer-file-name)))
		;; Enable kernel mode for the appropriate files
		(when (and filename
                           (string-match (expand-file-name "~/src/linux-trees")
					 filename))
                  (setq indent-tabs-mode t)
                  (setq show-trailing-whitespace t)
                  (c-set-style "linux-tabs-only")))))
#+END_SRC

#+RESULTS:
| (lambda nil (let ((filename (buffer-file-name))) (when (and filename (string-match (expand-file-name ~/src/linux-trees) filename)) (setq indent-tabs-mode t) (setq show-trailing-whitespace t) (c-set-style linux-tabs-only)))) | (lambda nil (let ((filename (buffer-file-name))) (when (and filename (string-match (expand-file-name ~/src/linux-trees) filename)) (setq indent-tabs-mode t) (setq show-trailing-whitespace t c-basic-offset 8 cdefault-style linux tab-width 8) (define-key c-mode-base-map (kbd RET) (quote newline-and-indent)) (c-set-style linux-tabs-only)))) | my:init-ac-c-headers | (lambda nil (let ((filename (buffer-file-name))) (if (and filename (string-match (expand-file-name ~/src/linux-trees) filename)) (progn (setq indent-tabs-mode t) (setq show-trailing-whitespace t c-basic-offset 8 cdefault-style linux tab-width 8) (define-key c-mode-base-map (kbd RET) (quote newline-and-indent)) (c-set-style linux-tabs-only))))) |

#+BEGIN_SRC emacs-lisp
  (semantic-mode 1)
  (defun my/add-semantic-to-autocomplete ()
    (add-to-list 'ac-sources 'ac-source-semantic))
  (add-hook 'c-mode-common-hook 'my/add-semantic-to-autocomplete)
#+END_SRC

#+RESULTS:
| my/add-semantic-to-autocomplete |

Define a function that intializes auto-complete-c-headers and gets
called for c/c++ hooks

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete-c-headers
    :ensure t
    :config
    (add-to-list 'ac-sources 'ac-source-c-headers))

  (defun my:init-ac-c-headers ()
    (require 'auto-complete-c-headers)
    (add-to-list 'achead:include-directories '"/usr/lib/gcc/x86_64-linux-gnu/4.8/include")
    (add-to-list 'achead:include-directories '"/usr/src/linux-headers-3.13.0-37/include/")
    (add-to-list 'achead:include-directories '"/usr/src/linux/include/"))

  (add-hook 'c++-mode-hook 'my:init-ac-c-headers)
  (add-hook 'c-mode-hook 'my:init-ac-c-headers)
#+END_SRC

#+RESULTS:
| my:init-ac-c-headers |

Use iedit for refactoring

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :config
    (define-key global-map (kbd "C-c ;") 'iedit-mode))
#+END_SRC

#+RESULTS:
: t

Use flycheck for syntax checking

#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure flycheck-cstyle
      :config
      (eval-after-load 'flycheck
	'(progn
	   (require 'flycheck-cstyle)
	   (flycheck-cstyle-setup)
	   (flycheck-add-next-checker 'c/c++-cppcheck '(warning . cstyle))))
      (global-flycheck-mode)
      (add-hook 'c-mode-hook
		(lambda () (setq flycheck-gcc-include-path
				 (list "/usr/src/linux-headers-3.13.0-37-generic/include"
				       "/usr/src/linux-headers-4.4.0-22/include"
				       "/usr/src/linux/include" )))))
#+END_SRC

#+RESULTS:
: t

Highlight TODO/FIXME/etc

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook
            (lambda()
              (font-lock-add-keywords nil
                                      '(("\\<\\(FIXME\\|TODO\\|XXX+\\|BUG\\):"
                                         1 font-lock-warning-face prepend)))))
#+END_SRC

#+RESULTS:
| (lambda nil (font-lock-add-keywords nil (quote ((\<\(FIXME\ | TODO\ | XXX+\ | BUG\): 1 font-lock-warning-face prepend))))) | (lambda nil (setq flycheck-gcc-include-path (list (expand-file-name /usr/src/linux-headers-3.13.0-37-generic/include/y)))) | my:init-ac-c-headers | (lambda nil (let ((filename (buffer-file-name))) (if (and filename (string-match (expand-file-name ~/src/linux-trees) filename)) (progn (setq indent-tabs-mode t) (setq show-trailing-whitespace t) (c-set-style linux-tabs-only))))) |

** WebDev

For work I need some php/javascript combination support. Web-mode
gives me what I need so far.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (defun my-setup-php ()
      ;; enable web mode
      (web-mode)

      ;; make these variables local
      (make-local-variable 'web-mode-code-indent-offset)
      (make-local-variable 'web-mode-markup-indent-offset)
      (make-local-variable 'web-mode-css-indent-offset)

      ;; set indentation, can set different indentation level for different code type
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-markup-indent-offset 2))
    (add-to-list 'auto-mode-alist '("\\.php$" . my-setup-php))
    )
#+END_SRC

#+RESULTS:
: t

I started coding Javascript lately and thus an appropriate mode is
needed. [[http://truongtx.me][Truong TX]] gave a nice example.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))

  (use-package js2-mode
    :ensure t
    :init
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (setq js2-highlight-level 3))

  (use-package ac-js2
    :ensure t
    :init
    (add-hook 'js2-mode-hook 'ac-js2-mode))


  (use-package flymake-jslint
    :ensure t
    :config
    (add-to-list 'load-path "~/git/lintnode")
    (setq lintnode-location "~/git/lintnode")
    (setq lintnode-jslint-excludes (list 'nomen 'undef 'plusplus 'onevar 'white))
    (add-hook 'js-mode-hook
	      (lambda()
		(lintnode-hook))))
#+END_SRC

#+RESULTS:
: t

