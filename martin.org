* Personal Information

If for some reason any application will need personal information,
here they are ;-)

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Martin Homuth")
#+END_SRC

#+RESULTS:
: Martin Homuth

Load all the things I don't like to share with the world or think is
better be extracted from this file. The following things are expected:
- martin-caldav-url
- user-mail-address
- fontsize
- mytheme
- transparency

#+BEGIN_SRC emacs-lisp
  (let ((file (expand-file-name "~/.emacs.d/secrets")))
    (if (file-exists-p file)
        (load file)))
#+END_SRC

#+RESULTS:
: t

* Emacs Initialization

These settings are for emacs internals, nothing specific.

** Add Package Sources

Use additional sources for the packages, and ensure that use-package
is available

   #+BEGIN_SRC emacs-lisp
     (unless (assoc-default "melpa" package-archives)
       (add-to-list 'package-archives
                    '("melpa" . "http://melpa.org/packages/")))

     (unless (assoc-default "org" package-archives)
       (add-to-list 'package-archives
                    '("org" . "http://orgmode.org/elpa/")))

     (unless (package-installed-p 'use-package)
       (package-install 'use-package))
     (require 'use-package)

   #+END_SRC

  /data/github/emacs-org/ #+RESULTS:

** Emacs Fonts and Locale
#+BEGIN_SRC emacs-lisp
  (when (boundp 'fontsize)
    (add-to-list 'default-frame-alist
               `(font . ,(concat "DejaVu Sans Mono-" (number-to-string fontsize)))))
  ;; disable CJK coding/encoding
  (setq utf-translate-cjk-mode nil)
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-file-name-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)

  ;; backwards compatibility
  (if (boundp buffer-file-coding-system)
      (setq buffer-file-coding-system 'utf-8)
    (setq default-buffer-file-coding-system 'utf-8))

  ;; Treat clipboard as UTF-8 string first
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+END_SRC

#+RESULTS:
| UTF8_STRING | COMPOUND_TEXT | TEXT | STRING |

** Themes

Move the theme setting to the personal file and load on demand as
different machines might use different themes. Common stuff is still
hard-coded in here.

#+BEGIN_SRC emacs-lisp
          ;;; As mytheme can be nil, guard it
  (if (not (or (eq (boundp 'mytheme) nil)
                (eq mytheme nil)))
      (load-theme mytheme t))
  (setq-default cursor-type 'box)
    ;;; set transparency
  (when (and (boundp 'transparency)
            (eq transparency t))
      (set-frame-parameter (selected-frame) 'alpha '(85 . 50))
      (add-to-list 'default-frame-alist '(alpha . (85 . 50))))
#+END_SRC

#+RESULTS:
: t

*** Centered Cursor Mode

#+BEGIN_SRC emacs-lisp
  (use-package centered-cursor-mode
    :ensure t
    :config (progn
    (centered-cursor-mode t)
    (global-centered-cursor-mode t)))

#+END_SRC

#+RESULTS:
: t

** Server

Starting the server at emacs start should be handy someday..

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

#+RESULTS:

** Backup

The file backups emacs uses are pretty annoying, so I place them in a
separate directory instead of next to the file in use. If needed these
files are accessible there quite easily.

If this variable is nil, or it fails to match a filename, the backup
is made in the original file's directory. This is what I really don't
want.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

** Add elisp directory and other files

Sacha uses external (wrt not package) files, which I'll enable too,
just to make sure it is there if I ever need it.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (expand-file-name "~/elisp"))
  (setq use-package-verbose t)
  (use-package auto-compile
    :ensure t
    :init (setq load-prefer-newer t)
    :config (auto-compile-on-load-mode))
#+END_SRC

#+RESULTS:
: t

** General Configuration

#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (line-number-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (delete-selection-mode t)
  (show-paren-mode 1)

  (setq fill-column 85
        initial-scratch-message ""
        show-paren-delay 0
        show-paren-style 'parenthesis
        visible-bell t
        show-paren-delay 0
        show-paren-style 'parenthesis
        visible-bell t)

  ;; Whitespaces... A colleague of mine showed me the horror of not
  ;; considering whitespaces and thus they are shown always and everywhere!
  (setq-default show-trailing-whitespace t)
#+END_SRC

#+RESULTS:
: t

A good addition is to toggle every whitespace character on demand.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure t
    :bind ("C-c T w" . whitespace-mode)
    :init
    (setq whitespace-line-column nil
          whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [9166 10])
                                        (tab-mark 9 [9654 9] [92 9])))
    :config
    (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
    :diminish whitespace-mode)
#+END_SRC

#+RESULTS:

** Helm - Interactive Completion
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure helm
    :diminish helm-mode
    :config
    (progn
      (setq helm-candidate-number-limit 100
            helm-idle-delay 0.0
            helm-input-idle-delay 0.01
            helm-quick-update t
            helm-M-x-requires-pattern nil)
      (helm-mode))
    :bind (("C-c h" . helm-mini)
           ("C-h a" . helm-apropos)
           ("C-x C-f" . helm-find-files)
           ("C-x C-b" . helm-buffers-list)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x c o" . helm-occur)
           ("C-x c s" . helm-scoop)))
#+END_SRC

#+RESULTS:
: helm-scoop

As helm-find-files always shows the '.' and '..' directories,
navigating through a tree is quite cumbersome. The following snippet
filters the candidates that solely consist of '.' and '..' names.

#+BEGIN_SRC emacs-lisp
  (advice-add 'helm-ff-filter-candidate-one-by-one
              :around (lambda (fcn file)
                        (unless (string-match "\\(?:/\\|\\`\\)\\.\\{2\\}\\'" file)
                          (funcall fcn file))))
#+END_SRC

** Ivy

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t)
  (use-package ivy :ensure t
    :diminish (ivy-mode . "")
    :bind
    (:map ivy-mode-map
          ("C-'" . ivy-avy))
    :config
    (ivy-mode 1)
    ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; number of result lines to display
    (setq ivy-height 10)
    ;; does not count candidates
    (setq ivy-count-format "(%d/%d) ")
    ;; no regexp by default
    (setq ivy-initial-inputs-alist nil)
    ;; configure regexp engine.
    (setq ivy-re-builders-alist
          ;; allow input not in order
          '((t   . ivy--regex-ignore-order))))
#+END_SRC

#+RESULTS:
: ivy-avy

** Hydra

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure windmove
    :ensure ace-window
    :ensure hydra
    :init
    (defhydra hydra-zoom (global-map "<f2>")
      "zoom"
      ("g" text-scale-increase "in")
      ("l" text-scale-decrease "out"))
    (global-set-key
     (kbd "C-M-o")
     (defhydra hydra-window ()
       "window"
       ("h" windmove-left)
       ("j" windmove-down)
       ("k" windmove-up)
       ("l" windmove-right)
       ("v" (\lambda ()
             (interactive)
             (split-window-right)
             (windmove-right))
        "vert")
       ("x" (\lambda ()
             (interactive)
             (split-window-below)
             (windmove-down))
        "horz")
       ("t" transpose-frame "'")
       ("o" delete-other-windows "one" :color blue)
       ("a" ace-window "ace")
       ("s" ace-swap-window "swap")
       ("d" ace-delete-window "del")
       ("i" ace-maximize-window "ace-one" :color blue)
       ("b" switch-to-buffer "buf")
       ("m" headlong-bookmark-jump "bmk")
       ("q" nil "cancel"))))
#+END_SRC

#+RESULTS:

** Startup File

Load my personal org file after startup.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        initial-buffer-choice (file-truename "~/git/CG_bitbucket/org/personal.org"))
#+END_SRC

#+RESULTS:
: /home/mhomuth/git/CG_bitbucket/org/personal.org

** Exit Confirmation

Even though unsaved buffers saved me lots of times due to prompting
for save, it happened quite often that I closed Emacs because of
mistyping. Maybe a confirmation helps and is not really annoying -
when in window system.

#+BEGIN_SRC emacs-lisp
  (defun martin-save-buffers-kill-emacs-with-confirm ()
    "Thanks to jsled for this method"
    (interactive)
    (if (window-system)
	(if (null current-prefix-arg)
	    (if (y-or-n-p "Are you sure you want to quit?")
		(save-buffers-kill-emacs))
	  (save-buffers-kill-emacs))
      (save-buffers-kill-terminal)))
  (global-set-key "\C-x\C-c" 'martin-save-buffers-kill-emacs-with-confirm)
#+END_SRC

#+RESULTS:
: martin-save-buffers-kill-emacs-with-confirm

** Snippets

From Sacha Chuas Configuration for testing

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode ;; used to remove mode line information that is not used
    :init (yas-global-mode)
    :config
    (progn
      (yas-global-mode)
      (add-hook 'hippie-expand-try-functions-list 'yas-hippie-try-expand)
      (setq yas-key-syntaxes '("w_" "w_." "^ "))
      (setq yas-snippet-dirs '("~/.emacs.d/snippets/"
                               "~/.emacs.d/elpa/yasnippet-20170717.1946/snippets/"))
      (setq yas-expand-only-for-last-commands nil)
      (yas-global-mode 1)
      (bind-key "\t" 'hippie-expand yas-minor-mode-map)))
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
  (setq default-cursor-color "gray")
  (setq yasnippet-can-fire-cursor-color "purple")

  ;; It will test whether it can expand, if yes, cursor color -> green.
  (defun yasnippet-can-fire-p (&optional field)
    (interactive)
    (setq yas--condition-cache-timestamp (current-time))
    (let (templates-and-pos)
      (unless (and yas-expand-only-for-last-commands
                   (not (member last-command yas-expand-only-for-last-commands)))
	(setq templates-and-pos (if field
                                    (save-restriction
                                      (narrow-to-region (yas--field-start field)
							(yas--field-end field))
                                      (yas--templates-for-key-at-point))
                                  (yas--templates-for-key-at-point))))
      (and templates-and-pos (first templates-and-pos))))

  (defun my/change-cursor-color-when-can-expand (&optional field)
    (interactive)
    (when (eq last-command 'self-insert-command)
      (set-cursor-color (if (my/can-expand)
                            yasnippet-can-fire-cursor-color
                          default-cursor-color))))

  (defun my/can-expand ()
    "Return true if right after an expandable thing."
    (or (abbrev--before-point) (yasnippet-can-fire-p)))

  (add-hook 'post-command-hook 'my/change-cursor-color-when-can-expand)

  (defun my/insert-space-or-expand ()
    "For binding to the SPC SPC keychord."
    (interactive)
    (condition-case nil (or (my/hippie-expand-maybe nil) (insert "  "))))
#+END_SRC

#+RESULTS:
: my/insert-space-or-expand

** Dashboard

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (progn
      (dashboard-setup-startup-hook)
      (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))
            dashboard-items '((agenda . 10)
                              (projects . 10)
                              (bookmarks . 10))
            dashboard-center-content t
            )
      (setq dashboard-set-heading-icons t)
      (setq dashboard-set-file-icons t)
      (setq dashboard-set-navigator t)
      )
    )
#+END_SRC

#+RESULTS:
: t

** Key Bindings
#+BEGIN_SRC emacs-lisp
  ;; General
  (global-set-key "\C-cw" 'compare-windows)
  (global-set-key "\C-x\C-m" 'execute-extended-command)
  (global-set-key "\C-c\C-m" 'execute-extended-command)
  (global-set-key "\C-w" 'backward-kill-word)
  (global-set-key "\C-x\C-k" 'kill-region)
  (global-set-key "\C-c\C-k" 'kill-region)
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-unset-key (kbd "C-z")) ;; who needs that anyways?
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "M-O") 'mh-prev-other-window)
  (global-unset-key "\C-xf")
  (global-set-key [f1] 'eshell)
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "C-c o") 'ff-find-other-file)
  (global-set-key (kbd "C-x r l") 'counsel-bookmark)
  ;; Org-Mode
  (bind-key "C-c r" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c L" 'org-insert-link-global)
  (bind-key "C-c O" 'org-open-at-point-global)
  (bind-key "<f9>" 'org-agenda-list)
  (bind-key "C-c v" 'org-show-todo-tree org-mode-map)
  (bind-key "C-c C-r" 'org-refile org-mode-map)
  (bind-key "C-c R" 'org-reveal org-mode-map)
#+END_SRC

#+RESULTS:
: org-agenda-clock-in

#+END_SRC

#+RESULTS:
: magit-status


* Navigation
** Better Beginning Of The Line

Thanks to Howard Abrams for this neat function!

#+BEGIN_SRC emacs-lisp
  (defun smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line] 'smarter-move-beginning-of-line)
  (global-set-key [remap org-beginning-of-line]  'smarter-move-beginning-of-line)

#+END_SRC

#+RESULTS:
: smarter-move-beginning-of-line
** Previous other window

As there appears not to be any simple function to return to the
previous window instead of directly passing a negative argument to

#+BEGIN_SRC emacs-lisp
  (defun mh-prev-other-window()
    "Simple function wrapper to `other-window' with a negative argument"
    (interactive)
     (other-window -1))
#+END_SRC


** NeoTree

NeoTree seems really nice

#+BEGIN_SRC emacs-lisp
  (use-package neotree
    :ensure t
    :bind (("M-n" . neotree-toggle))
    )
#+END_SRC

** Moving Files

Moving files using /rename-file/ or /dired-do-rename/ does not modify the
buffer of that file, which is not what I usually want. Taken from [[http://zck.me/emacs-move-file][here]]
is a method to not just rename the file but also the buffer associated
with the file.

#+BEGIN_SRC emacs-lisp
  (defun move-file (new-location)
    "Write this file to NEW-LOCATION, and delete the old one."
    (interactive (list (if buffer-file-name
			   (read-file-name "Move file to: ")
			 (read-file-name "Move file to: "
					 default-directory
					 (expand-file-name (file-name-nondirectory (buffer-name))
							   default-directory)))))
    (when (file-exists-p new-location)
      (delete-file new-location))
    (let ((old-location (buffer-file-name)))
      (write-file new-location t)
      (when (and old-location
		 (file-exists-p new-location)
		 (not (string-equal old-location new-location)))
	(delete-file old-location))))

  (bind-key "C-x C-m" 'move-file)
#+END_SRC

** Dired

Handling dired buffers is kind of cumbersome for me, especially
because opening a folder means more buffers for every folder I
enter. This is not bad per se, but not really what I would
like. Following the great emacs news by Sacha Chua, I found [[http://xenodium.com/#drill-down-emacs-dired-with-dired-subtree][this]] on
reddit:

#+BEGIN_SRC emacs-lisp
  (use-package dired-subtree
    :ensure t
    :after dired
    :config
    (setq dired-subtree-use-backgrounds nil)
    (bind-key "<tab>" #'dired-subtree-toggle dired-mode-map)
    (bind-key "<backtab>" #'dired-subtree-cycle dired-mode-map))
#+END_SRC

#+RESULTS:
: t

* Editing
** eshell

Eshell seems to be a great tool, but sometimes it is kind of
unhandy. There are two things that come to mind really quick:
1. whitespace mode when ls-ing
2. auto-completion tabs through the directories in the wrong order.
   This is due to the fact, that the completion uses the last-modified
   entry first. Basis for that is the function stored in
   "eshell-cmpl-compare-entry-function".
3. when re-entering eshell using <f1> the old position stays, I'd like
   the shell when entered with the key to change the wd to the buffer
   I entered the eshell with

Let's fix these things

#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq show-trailing-whitespace nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq eshell-cmpl-compare-entry-function (quote string-lessp))

#+END_SRC

** Auto Fill
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook 'turn-on-auto-fill)
     (add-hook 'c-mode-hook 'turn-on-auto-fill)
     (add-hook 'TeX-mode-hook 'turn-on-auto-fill)
   #+END_SRC

  /data/github/emacs-org/ #+RESULTS:
   | turn-on-auto-fill |

** Poporg

For comment formatting the plugin 'poporg' is very useful, with it you
can popup a buffer when the cursor is within a comment and edit the
comment contents in an org-mode buffer. The result however is the
plain text of course.

#+BEGIN_SRC emacs-lisp
  (use-package poporg
    :ensure t
    :bind (("C-c /" . poporg-dwim)))
#+END_SRC

#+RESULTS:
: poporg-dwim

** Default input method

I use the 'german-prefix' input method regularly and thus this should
be the default all the time. Maybe I'll tweak that someday if becomes
cumbersome.

#+BEGIN_SRC emacs-lisp
  (setq default-input-method "german-prefix")
#+END_SRC

#+RESULTS:
: german-prefix

* Version Control
** Git

Magit seems to be the one and only package when dealing with git
repositories. We will see, if there is something else needed ever.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :init
  (setq magit-auto-revert-mode nil)
  (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

#+RESULTS:

** Symbolic Links

The default behavior of emacs is to ask whether to follow symbolic
links or not. If not following the link, the `file` is opened, but
there can't be interaction with the version control (magit) and thus I
like the default behavior to be follow the links.

#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

** Projectile

As switching between projects becomes more and more cumbersome, I
decided to finally head over to projectile and give it a try.

#+BEGIN_SRC emacs-lisp
    (use-package projectile
      :ensure t
      :ensure helm-projectile
      :bind (("C-c P" . projectile-switch-project))
      :config
      (projectile-global-mode)
      (setq projectile-enable-caching t
            projectile-switch-project-action 'projectile-dired
            )

      )

#+END_SRC

#+RESULTS:
: projectile-switch-project

* Communication
** Mail

At work I am using mutt for handling my emails, mostly because the
accessibility to all the other buffers I have opened and in part also
because I am using a en_US keyboard layout which can be kind of
problematic in official german emails. I used mutt for quite some time
now and I just found out, that I don't use the appropriate mode for my
emails. Let's fix that.

[[https://www.emacswiki.org/emacs/MuttInEmacs][Emacs Wiki]]

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '(".*mutt.*" . message-mode))
  (setq mail-header-separator "")
  (add-hook 'message-mode-hook
	    'turn-on-auto-fill
	    (function
	     (lambda ()
	       (progn
		 (local-unset-key "\C-c\C-c")
		 (define-key message-mode-map "\C-c\C-c" '(lambda ()
							    "save and exit quickly"
							    (interactive)
							    (save-buffer)))))))
#+END_SRC

#+RESULTS:
| turn-on-auto-fill |

Aaaand, it would be gread to use org tables in mails as well.

#+BEGIN_SRC emacs-lisp
  (add-hook 'message-mode-hook 'turn-on-orgtbl)
#+END_SRC

*** notmuch and such

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cm" 'notmuch)
  (setq sendmail-program "/usr/bin/msmtp"
	notmuch-search-oldest-first nil
	mail-specify-envelope-from t
	message-sendmail-envelope-from 'header
	mail-specify-envelope-from 'header
	notmuch-show-all-multipart/alternative-parts nil)
#+END_SRC

#+RESULTS:
: /usr/bin/msmtp

Initial cursor position in hello window

#+BEGIN_SRC emacs-lisp
  (add-hook 'notmuch-hello-refresh-hook
		(lambda ()
                  (if (and (eq (point) (point-min))
                           (search-forward "Saved searches:" nil t))
                      (progn
			(forward-line)
			(widget-forward 1))
                    (if (eq (widget-type (widget-at)) 'editable-field)
			(beginning-of-line)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
   (setq notmuch-crypto-process-mime t)
#+END_SRC

Faces

#+BEGIN_SRC emacs-lisp
  (setq notmuch-search-line-faces '(("unread" :weight bold)
                                    ("flagged" :foreground "red")))
#+END_SRC

Modeline

#+BEGIN_SRC emacs-lisp
  (setq martin/notmuch-activity-string "")
  (add-to-list 'global-mode-string '((:eval martin/notmuch-activity-string)) t)
  (defun martin/get-notmuch-incoming-count ()
    (string-trim
     (shell-command-to-string
      "notmuch count tag:inbox AND tag:unread AND '\(folder:INBOX or folder:INBOX.Eyeo\)'")))
  (defun martin/format-notmuch-mode-string (count)
    (concat " mails[" (if (string= count "0") "" count) "]"))
  (defun martin/update-notmuch-activity-string (&rest args)
    (setq martin/notmuch-activity-string
          (martin/format-notmuch-mode-string (martin/get-notmuch-incoming-count)))
    (force-mode-line-update))
  (add-hook 'notmuch-after-tag-hook 'martin/update-notmuch-activity-string)
  (defcustom notmuch-presync-hook nil
    "Hook run before notmuch is synchronised"
    :type 'hook)
  (defcustom notmuch-postsync-hook '(martin/update-notmuch-activity-string)
    "Hook run after notmuch has been synchronised"
    :type 'hook)

#+END_SRC

#+RESULTS:
: martin/update-notmuch-activity-string

* Learning


* Startup

Testing some scripts for startup

#+BEGIN_SRC sh
  #!/bin/bash

  #set -x

  CG=$HOME/git/CG_bitbucket
  GH=$HOME/github

  err () {
      notify-send "$1"
      exit 1
  }

  REPOSITORIES="\
                   $CG/eudyptula \
                   $CG/org \
                   $CG/misc \
                   $CG/opencv-testbed \
                   $GH/emacs-org \
                   $GH/algorithms \
                   $GH/psp \
                   $GH/psp4android \
                   $GH/thelinuxprogramminginterface \
  "

  for repo in $REPOSITORIES; do
      if [ ! -d $repo ]; then
	  err "repo $(basename $repo) is not available"
      fi

      # execute everything in a subshell, may be useful later on
      (
	  cd $repo

	  status=$(git status -s)
	  if [ "y$status" != "y" ]; then
	      # can be unstaged or untracked
	      if [ $(expr match "$status" '^??.*') -eq 0 ]; then  # if unstaged
		  err "$(basename $repo) has unstaged changes"
	      fi
	  fi

	  git status | grep -e behind >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pulling changeds from $repo"
	      {
		  git pull
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to pull repo $repo"
	      fi
	  fi

	  git status | grep -e ahead >/dev/null
	  ret=$?
	  if [ $ret -eq 0 ]; then
	      echo "Pushing changes to $repo"
	      {
		  git push
	      } &>/dev/null
	      if [ $? -eq 1 ]; then
		  err "unable to push repo $repo"
	      fi
	  fi
      )
  done
#+END_SRC

#+RESULTS:

* Ledger

I use ledger to collect any accounting data.

#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t)

  (setenv "PATH" (concat (concat "/home/" user-login-name "/bin:")
			 (getenv "PATH")))
  (push (concat "/home/" user-login-name "/bin") exec-path)
#+END_SRC

(getenv "PATH")
#+RESULTS:

* Org-Mode
** General

As the most awesome people do, I too use org-mode! :)

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :init
    (setq org-log-done 'time)
    (setq org-clock-report-include-clocking-task t)
    :config
    (add-hook 'org-clock-in-hook 'martin/org-clock-in-set-state-to-started)
    (add-hook 'org-babel-after-execute-hook 'org-display-inline-images)
    (setq org-hide-emphasis-markers t
          org-src-window-setup 'current-window
	  org-use-speed-commands t)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((shell . t)
       (shell . t)
       (js . t)
       (python . t)
       (C . t)
       (css . t)
       (dot . t)
       (plantuml . t)
       (emacs-lisp . t)))
    )

  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook (lambda() (org-bullets-mode 1)))
    (setq
     org-bullets-bullet-list '("✙" "♱" "♰" "☥" "✞" "✟" "✝" "†" "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥")
     org-ellipsis "➔"))
  #+END_SRC

#+RESULTS:
: t

Using actual circular bullets for bullet lists

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

#+RESULTS:

** Taking Notes

Setting the directories for the notes to be placed in - this will be
synced soonish.

#+BEGIN_SRC emacs-lisp
  (setq org-directory (expand-file-name "~/git/CG_bitbucket/org"))
  (setq org-default-notes-file (expand-file-name "~/git/CG_bitbucket/org/personal.org"))
#+END_SRC

#+RESULTS:
: ~/git/org/personal.org

*** Templates

Let's use =org-capture= to quickly add the things that come to mind all the time :)

#+BEGIN_SRC emacs-lisp
  (defvar martin/org-project-template "* %^{Project Description} %^g
  /data/github/emacs-org/:PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00|8:00}
  /data/github/emacs-org/:END:
  SCHEDULED: %^t
  Why? %?
  What?
  Who?
  Where?
  How?
  Outcome?
  ,** Brainstorming
    Collect 10 Ideas
  " "Full Project Description")
  (defvar martin/org-basic-task-template "* TODO %^{Task}
  SCHEDULED: %^t
  /data/github/emacs-org/:PROPERTIES:
  :Effort: %^{effort|1:00|0:05|0:10|0:15|0:30|0:45|2:00|4:00}
  /data/github/emacs-org/:END:
  %?
  " "Basic task data")
  (defvar martin/org-programming-workout-template "* %^{Workout Description}
  /data/github/emacs-org/:PROPERTIES:
  :Effort: %^{effort|0:05|0:10|0:15|0:20|0:25}
  /data/github/emacs-org/:END:
  %^g%?
  " "Programming Workout Template")
  (defvar martin/org-journal-template
    "**** %^{Description} %^g
  %?"
    "Journal Template")
  (setq org-capture-templates
        `(("t" "Tasks" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/personal.org") "INBOX")
           ,martin/org-basic-task-template)
          ("T" "Quick Task" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/personal.org") "INBOX")
           "* TODO %^{Task}"
           :immediate-finish t)
          ("j" "Journal entry" plain
           (file+olp+datetree "/data/git/CG_bitbucket/org/journal.org")
           ,martin/org-journal-template)
          ("a" "Appointments" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/organizer.org") "Appointments")
           "* %?\n%i")
          ("d" "Decisions" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/personal.org") "Decisions")
           "* %?\n%i")
          ("p" "Project" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/personal.org") "Projects")
           ,martin/org-project-template)
          ("W" "Workout" entry
           (file+headline (file-truename "~/git/CG_bitbucket/org/personal.org") "Primary Skills")
           ,martin/org-programming-workout-template)))
  (bind-key "C-M-r" 'org-capture)
#+END_SRC

#+RESULTS:
: org-capture

*** Refiling

=org-refile= lets you organize notes by typing in the headline to file
them under.

#+BEGIN_SRC emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-entry nil)
#+END_SRC

#+RESULTS:


** Managing Tasks

*** Track TODO state

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"   ; next action
           "TOBLOG(b)"  ; next action
           "REVIEW(r)"  ; next action
           "STARTED(s)"
           "WAITING(w@/!)"
           "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
          (sequence "TODELEGATE(-)" "DELEGATED(d)" "|" "COMPLETE(x)")))

  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "green" :weight bold))
          ("DONE" . (:foreground "cyan" :weight bold))
          ("REVIEW" . (:foreground "blue" :weight bold))
          ("WAITING" . (:foreground "red" :weight bold))
          ("SOMEDAY" . (:foregound "gray" :weight bold))))
#+END_SRC

#+RESULTS:
| TODO    | :foreground | green | :weight | bold |
| DONE    | :foreground | cyan  | :weight | bold |
| REVIEW  | :foreground | blue  | :weight | bold |
| WAITING | :foreground | red   | :weight | bold |
| SOMEDAY | :foregound  | gray  | :weight | bold |

*** Tag Tasks with GTD-ish contexts

This defines the key commands for those, too.

#+BEGIN_SRC emacs-lisp
  (setq org-tag-alist '(("call" . ?c)
                        ("@computer" . ?l)
                        ("@home" . ?h)
                        ("errand" . ?e)
                        ("@office" . ?o)
                        ("@anywhere" . ?a)
                        ("meetings" . ?m)
                        ("readreview" . ?r)
                        ("writing" . ?w)
                        ("programming" . ?p)
                        ("short" . ?s)
                        ("quantified" . ?q)
                        ("highenergy" . ?1)
                        ("lowenergy" . ?0)
                        ("business" . ?B)))
#+END_SRC

#+RESULTS:

** Org Agenda

*** Basic Configuration
#+BEGIN_SRC emacs-lisp
  (setq my-org-agenda-files-list (append
                                  (file-expand-wildcards "~/git/CG_bitbucket/org/*.org"))
        org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      my-org-agenda-files-list)))
#+END_SRC

#+RESULTS:
| /home/mhomuth/git/CG_bitbucket/org/personal.org | /home/mhomuth/git/CG_bitbucket/org/work.org | /home/mhomuth/git/CG_bitbucket/org/journal.org | /home/mhomuth/git/CG_bitbucket/org/organizer.org |

This is some configuration of Sacha's
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-span 'week)
  (setq org-agenda-sticky nil)
  (setq org-agenda-show-log t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
  (setq org-columns-default-format "%50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS")
#+END_SRC

#+RESULTS:
: %50ITEM %12SCHEDULED %TODO %3PRIORITY %Effort{:} %TAGS

** Literate Programming

For syntax highlighting of org src blocks and disabling the
confirmation of executing those blocks the following variables are set

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil
        org-src-fontify-natively t
        org-src-tab-acts-natively t)
#+END_SRC

#+RESULTS:
: t

* Programming
** General

#+BEGIN_SRC emacs-lisp
  (use-package auto-complete
    :ensure t
    :config
    (ac-config-default)
    (global-auto-complete-mode t))
#+END_SRC

#+RESULTS:
: t

** Coverage

This enables googles coverage. The repository has to be downloaded to
the appropriate location and be enabled using the following snippet

#+BEGIN_SRC emacs-lisp
  ;;(add-to-list 'load-path "/home/mhomuth/elisp/coverage")
  ;;(require 'coverage)
#+END_SRC

#+RESULTS:
: coverage

** C

Linux kernel coding style adjustments

#+BEGIN_SRC emacs-lisp
  (defun c-lineup-arglist-tabs-only ()
    "Line up argument lists by tabs, not spaces"
    (let* ((anchor (c-langelem-pos c-syntactic-element))
           (column (c-langelem-2nd-pos c-syntactic-element))
           (offset (- (1+ column) anchor))
           (steps (floor offset c-basic-offset)))
      (* (max steps 1)
         c-basic-offset)))

  (defun my/general-c-mode-configuration ()
    (setq indent-tabs-mode t)
    (setq show-trailing-whitespace t
          c-basic-offset 8
          cdefault-style "linux"
          tab-width 8
          indent-tabs-mode t
          show-trailing-whitespace t
          c-set-style "linux-tabs-only")
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))
  (defun my/add-semantic-to-autocomplete ()
    (add-to-list 'ac-sources 'ac-source-semantic))

  (defun my/general-c++-mode-configuration ()
    (setq show-trailing-whitespace t
          c-basic-offset 4
          tab-width 4
          indent-tabs-mode nil)
    (define-key c-mode-base-map (kbd "RET") 'newline-and-indent))

  (add-hook 'c-mode-common-hook 'my/add-semantic-to-autocomplete)
  (add-hook 'c-mode-common-hook 'my/general-c-mode-configuration)
  (add-hook 'c++-mode-hook 'my/general-c++-mode-configuration)
  (add-hook 'c-mode-common-hook
            (lambda ()
              ;; Add kernel style
              (c-add-style
               "linux-tabs-only"
               '("linux" (c-offsets-alist
                          (arglist-cont-nonempty
                           c-lineup-gcc-asm-reg
                           c-lineup-arglist-tabs-only))))))
#+END_SRC

clang-format

#+BEGIN_SRC emacs-lisp
  (fset 'c-indent-region 'clang-format-region)
#+END_SRC

#+RESULTS:
: clang-format-region

Define a function that intializes auto-complete-c-headers and gets
called for c/c++ hooks

#+BEGIN_SRC emacs-lisp
    (use-package auto-complete-c-headers
      :ensure t
      :config
      (add-to-list 'ac-sources 'ac-source-c-headers))

    (defun my/init-ac-c-headers ()
      (add-to-list 'achead:include-directories '"/usr/src/linux/include/"))

    (add-hook 'c++-mode-hook 'my/init-ac-c-headers)
    (add-hook 'c-mode-hook 'my/init-ac-c-headers)
#+END_SRC

#+RESULTS:
| my/init-ac-c-headers |

Use iedit for refactoring

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :ensure t
    :config
    (define-key global-map (kbd "C-c ;") 'iedit-mode))
#+END_SRC

#+RESULTS:
: t

Use flycheck for syntax checking

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure flycheck-cstyle
    :config
    (eval-after-load 'flycheck
      '(progn
         (flycheck-cstyle-setup)
         (flycheck-add-next-checker 'c/c++-cppcheck '(warning . cstyle))))
    (global-flycheck-mode)
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-include-path
                               (list "/usr/src/linux/include" ))))
    (add-hook 'c-mode-hook
              (lambda () (setq flycheck-gcc-language-standard "c11")))
    (add-hook 'sh-mode-hook 'flycheck-mode)
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

#+RESULTS:
: t

Highlight TODO/FIXME/etc

#+BEGIN_SRC emacs-lisp
  (defun my-highlight-keywords-warning()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(FIXME\\|TODO\\|XXX+\\|BUG\\|TBD\\):"
			       1 font-lock-warning-face prepend))))
  (defun my-highlight-keywords-info()
    ""
    (font-lock-add-keywords nil
			    '(("\\<\\(NOTE\\|INFO\\):"
			       1 font-lock-comment-face prepend))))

  (add-hook 'c-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c-mode-hook 'my-highlight-keywords-info)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-warning)
  (add-hook 'c++-mode-hook 'my-highlight-keywords-info)
#+END_SRC

#+RESULTS:
| my-highlight-keywords-info | my-highlight-keywords-warning | fix-enum-class | my-highlight-keywords | my/init-ac-c-headers |

Add compile keybinding and adjust initial command

#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook
            (lambda () (define-key c-mode-base-map (kbd "C-c C-l") 'compile)))



#+END_SRC

** Shell

Finally fixing the indentation of my shell mode.

#+BEGIN_SRC emacs-lisp
  (defun martin-setup-sh-mode()
    "sh-mode customizations."
    (interactive)
    (setq sh-basic-offset 8
          sh-indentation 8))

  (add-hook 'sh-mode-hook 'martin-setup-sh-mode)
#+END_SRC

Use shellcheck

#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook 'flycheck-mode)
#+END_SRC

** XML

Who on earth would want xml files to be indented only with 2 spaces?!?

#+BEGIN_SRC emacs-lisp
  (setq nxml-child-indent 8
        nxml-attribute-indent 8)
#+END_SRC

** Java

Indentation is important :)

#+BEGIN_SRC emacs-lisp
  (add-hook 'java-mode-hook (lambda ()
                              (setq c-basic-offset 4)))
#+END_SRC

** C++

*** Indentation enum class

This indentation is not working in the original c++-mode, thus a fix is needed:

#+BEGIN_SRC emacs-lisp
  (defun inside-class-enum-p (pos)
    "Checks if POS is within the braces of a C++ \"enum class\"."
    (ignore-errors
      (save-excursion
	(goto-char pos)
	(up-list -1)
	(backward-sexp 1)
	(looking-back "enum[ \t]+class[ \t]+[^}]+"))))

  (defun align-enum-class (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	(c-lineup-topmost-intro-cont langelem)))

  (defun align-enum-class-closing-brace (langelem)
    (if (inside-class-enum-p (c-langelem-pos langelem))
	'-
      '+))

  (defun fix-enum-class ()
    "Setup `c++-mode' to better handle \"class enum\"."
    (add-to-list 'c-offsets-alist '(topmost-intro-cont . align-enum-class))
    (add-to-list 'c-offsets-alist
		 '(statement-cont . align-enum-class-closing-brace)))

  (add-hook 'c++-mode-hook 'fix-enum-class)
#+END_SRC

#+RESULTS:
| fix-enum-class | my/init-ac-c-headers |

** Linux
*** dts mode

After some time digging through device tree files it is time to use an
appropriate mode..

#+BEGIN_SRC emacs-lisp
  (use-package dts-mode
    :ensure t)
#+END_SRC

#+RESULTS:


** WebDev

For work I need some php/javascript combination support. Web-mode
gives me what I need so far.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (defun my-setup-php ()
      ;; enable web mode
      (web-mode)

      ;; make these variables local
      (make-local-variable 'web-mode-code-indent-offset)
      (make-local-variable 'web-mode-markup-indent-offset)
      (make-local-variable 'web-mode-css-indent-offset)

      ;; set indentation, can set different indentation level for different code type
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-markup-indent-offset 2))
    (add-to-list 'auto-mode-alist '("\\.php$" . my-setup-php))
    )
#+END_SRC

#+RESULTS:
: t

I started coding Javascript lately and thus an appropriate mode is
needed. [[http://truongtx.me][Truong TX]] gave a nice example.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))

  (use-package js2-mode
    :ensure t
    :init
    (add-hook 'js-mode-hook 'js2-minor-mode)
    (setq js2-highlight-level 3))

  (use-package ac-js2
    :ensure t
    :init
    (add-hook 'js2-mode-hook 'ac-js2-mode))


  (use-package flymake-jslint
    :ensure t
    :config
    (add-to-list 'load-path (file-truename "~/git/lintnode"))
    (setq lintnode-location (file-truename "~/git/lintnode"))
    (setq lintnode-jslint-excludes (list 'nomen 'undef 'plusplus 'onevar 'white))
    (add-hook 'js-mode-hook
	      (lambda()
		(lintnode-hook))))
#+END_SRC

#+RESULTS:
: t

** Common Lisp

I learned to love slime really quickly.

#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t)

  (setq inferior-lisp-program "/usr/bin/clisp")
#+END_SRC

* Org Settings
#+STARTUP: indent content hidestars
